# ADR 014:Secp256k1 签名延展性

## 语境

Secp256k1 具有两层延展性.
签名者有一个随机数，因此可以产生许多不同的有效签名.
本 ADR 与此无关.
第二层延展性基本上允许被赋予签名的人
从相同的公钥为相同的消息生成一个更有效的签名.
(他们甚至不必知道消息！)
这背后的数学原理将在下一节中解释.

请注意，在许多下游应用程序中，签名将出现在交易中，因此出现在 tx 哈希中.
这意味着如果有人广播带有 secp256k1 签名的交易，则该签名可以被 p2p 网络中的任何人更改为另一种形式.
因此 tx 哈希值会改变，而这个改变的 tx 哈希值可能会被提交.
这打破了您可以广播有效交易并等待其散列被包含在链中的假设.
一个例子是如果你在宇宙中广播一个 tx，
并在增加序列号之前等待它出现在链上.
如果提交了不同的 tx 哈希，您可能永远不会增加您的序列号.
消除第二层签名延展性问题可以简化下游开发.

### ECDSA 上下文

Secp256k1 是特定曲线上的 ECDSA.
签名的形式为 `(r, s)`，其中 `s` 是一个字段元素.
(特定字段是 `Z_n`，其中椭圆曲线的阶数为 `n`)
然而，`(r, -s)` 也是另一种有效的解决方案.
请注意，任何人都可以否定组元素，因此可以获得第二个签名.

## 决定

我们可以区分 ECDSA 签名的规范形式.
然后我们要求所有 ECDSA 签名都采用我们定义为规范的形式.
我们拒绝非规范形式的签名.

规范形式相当容易定义和检查.
它只是按字典顺序定义的 `s` 的两个值中较小的一个.
这是一个简单的检查，而不是检查是否`s < n`，而是检查`s <= (n - 1)/2`.
另一个使用此密码系统的示例
是这里的奇偶定义 https://github.com/zkcrypto/pairing/pull/30#issuecomment-372910663.

这与以太坊为解决 secp 延展性选择的解决方案相同.

## 建议的实施

Fork https://github.com/btcsuite/btcd，只需更新[parse sig method](https://github.com/btcsuite/btcd/blob/11fcd83963ab0ecd1b84b429b1efc1d2cdc6d5c5/btcec/signature.go#L19)和serialize5函数强制执行我们的规范形式.

## 状态

实施的

## 结果

### 积极的

- 让我们保持期望 tx 哈希出现在区块链中的能力.

### 消极的

- 在所有未来的实现中做更多的工作(虽然这是一个非常简单的检查)
- 需要我们维护另一个叉子

### 中性的
