# ADR 015:加密编码

## 语境

我们必须标准化我们在链上编码公钥和签名的方法.
目前我们对公钥和签名进行氨基编码.
我们在这里使用氨基的原因主要是因为易于支持
解析其他语言.
我们不需要它在密码系统中的可升级性属性，因为
需要调整编码的加密货币，可能需要被视为
一个新的密码系统.
(即使用新的公共参数)

## 决定

### 公钥

对于公钥，我们将继续在规范上使用氨基编码
公钥的表示.
(由密码系统本身定义的规范)
这有两个明显的缺点.
由于需要支持可升级性，氨基编码的空间效率较低.
氨基编码支持需要 fork protobuf 并添加这个新的接口支持
选择的语言中的选项.

然而，继续使用氨基的原因是人们可以创建代码
在已经拥有最新氨基库的语言中更容易.
这可能会在未来发生变化，如果它被认为是
不需要氨基来与 Tendermint 加密进行交互.

这里的空间效率论据被驳斥，理由是有
SDK 中的空间浪费严重得多.
公钥的空间要求不会引起很多问题
增加附加到每个验证器/帐户的空间.

在这里使用氨基的替代方法是我们创建一个枚举类型.
切换到枚举类型值得在发布后进行调查.
作为参考，部分氨基编码接口基本上是一个4字节的枚举
类型定义.
枚举类型只会将那 4 个字节更改为变体，并且会删除
protobuf 开销，但很难集成到现有 API 中.

### 签名

签名应该切换为`[]byte`.
签名中的空间效率非常重要，
因为它直接影响每笔交易的gas成本，
和链的吞吐量.
签名不需要对它们的类​​型进行编码(与公钥不同)
因为公钥必须是已知的.
因此，我们可以验证签名而无需对其类型进行编码.

当置于 state 中时，签名仍将是氨基编码的，但它将是
原始类型`[]byte` 被编码.

#### Ed25519

使用签名的规范表示.

#### Secp256k1

这里没有明确的规范表示.
签名有两个元素`r,s`.
这些字节被编码为`r || s`，其中 `r` 和 `s` 都是
32 字节长，大端编码.
这基本上是以太坊的编码，但没有领先的恢复位.

## 状态

实施的

## 结果

### 积极的

- 更节省空间的签名

### 消极的

- 我们对密码学有氨基依赖.

### 中性的

- 没有更改公钥
