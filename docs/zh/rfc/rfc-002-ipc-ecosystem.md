# RFC 002:Tendermint 中的进程间通信 (IPC)

## 变更日志

- 2021 年 9 月 8 日:初稿 (@creachadair)。


## 抽象的

Tendermint 共识节点、应用程序和运营商之间的通信
工具都使用不同的消息格式和传输机制。在一些
情况有多种选择。拥有所有这些选项使两者都变得复杂
代码和开发人员体验，并隐藏错误。为了支持更强大的，
值得信赖和可用的系统，我们应该记录哪些通信路径
是必不可少的，可以删除或缩小范围，以及我们可以做什么
针对最重要的用例进行改进。

本文件提出了各种不同大小和不同的可能改进
范围。具体的设计方案应该有自己的文档。


## 背景

Tendermint 状态复制引擎具有复杂的 IPC 足迹。

1. 共识节点使用网络化的点对点相互通信
   消息传递协议。

2. 共识节点与状态为正在的应用程序通信
   通过 [应用程序区块链接口 (ABCI)][abci] 复制。

3. 共识节点导出一个网络可访问的[RPC service][rpc-service]到
   支持[轻客户端][轻客户端]的操作(引导、调试)和同步。
   [`tendermint` CLI][tm-cli] 也使用此接口。

4. 共识节点导出一个 gRPC 服务，暴露了以下方法的子集
   (3)描述的RPC服务。这是为了简化
   已经使用 gRPC 与
   应用程序(通过 Cosmos SDK)，并且还想与共识对话
   节点而无需实现另一个 RPC 协议。

   共识节点的 gRPC 接口已被弃用并计划
   在即将发布的 Tendermint v0.36 版本中删除。

5. 共识节点可以选择与持有的“远程签名者”通信
   验证者密钥，可以为共识提供公钥和签名
   节点。此配置的既定目标之一是允许签名者
   在私有网络上运行，与共识节点分开，以便
   来自公共网络的共识节点的妥协会更少
   可能会暴露验证器密钥。

## 讨论:传输机制

### 远程签名者传输

远程签名者通过以下两种方式之一与共识节点通信:

1.“原始”:使用带有 varint 前缀的 TCP 或 Unix 域套接字
   协议缓冲区消息。在这种模式下，共识节点是服务器，
   远程签名者是客户端。

   此模式已被弃用，并打算将其删除。

2. gRPC:此模式使用与“原始”节点相同的 protobuf 消息，但使用一个
   标准加密 gRPC HTTP/2 存根作为传输。在这种模式下，
   远程签名者是服务器，共识节点是客户端。


### ABCI 运输

在 ABCI 中，_application_ 是服务器，Tendermint 共识引擎
是客户。大多数应用程序使用 [Cosmos SDK][cosmos-sdk] 实现服务器，
它处理 ABCI 交互的低级细节并提供
应用程序其余部分的高级接口。 SDK 是用 Go 编写的。

在 SDK 下，应用程序通过以下方式与 Tendermint 核心通信
两种方式:

- 进程内直接调用(适用于用 Go 编写并编译的应用程序)
  Tendermint 代码)。这是对常见情况的优化，其中
  应用程序是用 Go 编写的，以节省编组和
  在同一进程中解组请求和响应:
  [`abci/client/local_client.go`][local-client]

- 基于线格式 protobuf 消息的自定义远程过程协议
  使用套接字(“套接字协议”):[`abci/server/socket_server.go`][socket-server]

SDK 还提供了一个 [gRPC 服务][sdk-grpc] 从外部访问
应用程序，允许将交易广播到网络，查找
交易，并模拟交易成本。


### RPC 传输

共识节点RPC服务允许调用者查询共识参数
(创世数据、交易、提交)、节点状态(网络信息、健康
检查)、应用程序状态(abci_query、abci_info)、内存池状态和其他
节点的属性及其应用。该服务还提供了方法
允许将交易和证据注入(“广播”)到
区块链。

RPC 服务以多种方式公开:

- HTTP GET:查询可以作为 URI 参数发送，路径中带有方法名称。

- HTTP POST:查询可以作为 JSON-RPC 请求消息发送到
  HTTP POST 请求。服务器使用 JSON-RPC 的自定义实现
  与 [JSON-RPC 2.0 规范][json-rpc] 不完全兼容，但处理
  常见的情况。

- Websocket:可以通过 websocket 将查询作为 JSON-RPC 请求消息发送。
  此传输或多或少使用与 HTTP POST 相同的 JSON-RPC 管道
  处理程序。

  websocket端点还包括三个_only_导出的方法
  通过 websocket，它似乎支持事件订阅。

- gRPC:可能会以协议缓冲区格式向 gRPC 发出一部分查询
  上面(4)中描述的接口。如前所述，此端点已弃用
  并将在 v0.36 中删除。

### 简化的机会

**声明:** IPC 机制过多。

ABCI 的主要使用是通过 Cosmos SDK，这意味着
应用程序和共识节点一起编译成一个二进制文件，
并且共识节点直接调用应用程序的 ABCI 方法作为 Go
职能。

我们还需要一个真正的 IPC 传输来支持 ABCI 应用程序 _not_ 写在
去。还有几个已知的应用程序是用 Rust 编写的，例如
(包括[Anoma](https://github.com/anoma/anoma), Penumbra,
[Oasis](https://github.com/oasisprotocol/oasis-core)、暮光之城和
[Nomic](https://github.com/nomic-io/nomic))。理想情况下，我们最多只有一个
这种传输“内置”:自定义代理可以处理更深奥的情况。
从实用角度讲，gRPC 可能是这里的正确选择。

今天多头“RPC服务”的主要消费者是光
客户端和 `tendermin` 命令行客户端。可能有一些当地的
通过 curl 使用，但我希望这主要是临时的。 Ethan 报告说节点是
通常配置为阻塞 RPC 服务的端口，这对
安全，但使轻客户端的使用复杂化。

### 上下文:远程签名者问题

由于远程签名者需要一个安全的通信通道来交换密钥
和签名，并有望真正从节点远程运行(即，在一个
单独的物理服务器)，我们在这里可以做的并不多。我们应该
完成弃用和删除之间的“原始”套接字协议
共识节点和远程签名者，但使用 gRPC 是合适的。

我们可以做的主要改进是大大简化了实现，
一旦我们不再需要同时支持“原始”和 gRPC 传输。

### 背景:ABCI 问题

在 ABCI 的最初设计中，假设所有访问
应用程序应由共识节点调解。这个想法是在外面
访问可能会改变应用程序状态并破坏共识过程，这
依赖于应用程序的确定性。当然，即使没有外面
访问应用程序的行为可能具有不确定性，但允许其他
向它发送请求的程序被认为是在招惹麻烦。

相反，用户注意到大多数时候，为特定的工具编写的工具
应用程序不想直接与共识模块交谈。这
应用程序“拥有”共识引擎正在复制的状态机，所以
关心应用程序状态的工具应该与应用程序对话。
否则，他们将不得不深入了解 Tendermint(例如，它的
接口和数据结构)只是因为中介。

然而，对于客户端直接与应用程序交谈，还有另一个
关注点:共识节点是ABCI_client_，不方便
应用程序通过 ABCI 本身将工作“推送”到共识模块中。这
当前的实现通过调用共识节点的 RPC 来解决这个问题
服务，它公开了一个“ABCIQuery”厨房水槽方法，允许
应用程序在另一个方向戳 ABCI 消息的方法。

如果没有此 RPC 方法，您可以通过以下方式解决此问题(至少原则上是这样)
让共识模块“轮询”需要完成的工作的应用程序，
但这对性能和健壮性的影响并不令人满意，因为
以及更难理解。

显然已经讨论过尝试制作更双向的
共识节点和应用之间的通信，但是这个问题
好像还是没有解决。

ABCI 的另一个复杂之处是它要求应用程序(服务器)
维护[四个独立的连接][abci-conn]:一个用于“共识”操作
(BeginBlock, EndBlock, DeliverTx, Commit)，一个用于“mempool”操作，一个
用于“查询”操作，一种用于“快照”(状态同步)操作。
理由似乎是这些行动组应该能够
彼此同时进行。在实践中，它导致一个非常复杂的
状态管理问题来协调不同流之间的状态更新。
虽然 Go 中的应用程序作者大多与这种复杂性隔离
Cosmos SDK，维护这些独立流的管道很复杂，很难
理解，我们怀疑它包含并发错误和/或锁争用
影响性能的问题是微妙且难以确定的。

即使不改变任何 ABCI 操作的语义，这段代码也可以是
通过分离并发管理使更小更易于调试
并从 IPC 传输锁定:如果所有请求和响应都被路由
通过一个连接，服务器可以显式地维护优先级队列
请求和响应，并就何时锁定做出不太保守的决定
需要(或不需要)同步状态访问。有独立的队列，
服务器必须保守锁定，没有乐观调度是可行的。

这将是一个乏味的实现更改，但应该可以在没有
破坏任何现有的接口。更重要的是，它可能
解决了我们目前很多困难的并发和性能问题
看到轶事，但由于这些交织在一起而难以隔离
单独的消息流在运行时。

TODO:ABCI++ 对这个主题的影响？

### 上下文:RPC 问题

RPC 系统服务于多个 master，并且具有复杂的表面积。一世
相信有一些改进可以通过分离一些
这些担忧。

Tendermint 轻客户端目前使用 RPC 服务查找区块
和交易，并将 ABCI 查询转发到应用程序。光
客户端代理通过 websocket 使用 RPC 服务。 Cosmos IBC 中继器也
通过 websocket 使用 RPC 服务来监视事务事件，并使用
用于获取已发布交易的信息和证明的“ABCIQuery”方法。

使用 P2P 消息传递而不是 RPC 的一些工作已经在进行中
将轻客户端状态与网络的其余部分同步。 IBC中继，
但是，需要访问当前无法访问的事件系统
除了通过 RPC 接口。事件订阅_可以_通过 P2P 公开，
但这是一个更大的项目，因为它增加了 P2P 通信负载，并且可能
从而对共识的表现产生影响。

如果事件订阅可以移动到 P2P 网络中，我们完全可以
删除 websocket 传输，即使对于仍然需要访问
RPC 服务。在那之前，我们可能仍然能够缩小范围
websocket端点到_only_事件订阅，通过移动RPC的使用
服务器作为 ABCI 的代理到 gRPC 接口。

让 RPC 服务器对本地引导和操作仍然有意义，
但可以进一步简化。下面是一些具体的建议:

- 完全删除 HTTP GET 接口。

- 简化 JSON-RPC 管道以消除不必要的反射和包装。

- 删除 gRPC 接口(这已经为 v0.36 计划)。

- 将 websocket 接口与 RPC 服务的其余部分分开，并且
  将其限制为仅事件订阅。

  最终我们应该尝试完全移除 websocket 接口，但是我们
  一旦我们完成了一些工作，就需要重新审视(可能在新的 RFC 中)
  更容易的事情。

这些更改将保留操作员发出查询的能力
curl(但需要使用 JSON-RPC 而不是 URI 参数)。那会
对用户不那么友好，但对于不应该那样的用例
流行。

这些更改还将保持与现有的基于 JSON-RPC 的兼容性
代码路径，如 `tendermint` CLI 和轻客户端(甚至领先于
进一步的工作以消除这种依赖性)。

**设计目标:** 操作员应该能够禁止非本地访问
网络中任何节点上的 RPC 服务器，而不会影响
用于状态复制服务的网络，包括轻客户端。

**设计原则:** 实施和监控所需的所有沟通
共识网络应该使用 P2P，包括各种同步。

### ABCI 传输选项

当前的大部分使用是在 Go 中，其中大部分是由
Cosmos SDK，使用“直接调用”接口。大概有一些
有机会清理该代码的实现，特别是通过反转
哪个接口位于抽象堆栈的“顶部”(当前它起作用)
就像一个 RPC 接口，并转义到直接调用中)。然而，这
一般方法工作正常，不需要从根本上改变。

对于 _not_ 用 Go 编写的应用程序，剩下的两个选项是
“套接字”协议(varint 前缀的 protobuf 消息的另一种变体
非结构化流)和 gRPC。如果我们能摆脱一个就好了
其中之一是为了减少(不需要的？)可选性。

由于套接字协议和 gRPC 都依赖于协议缓冲区，因此
“socket”协议是最明显的删除选择。虽然 gRPC 更多
复杂的，_拥有_protobuf支持但_缺乏_gRPC的一组语言
支持很小。此外，gRPC 已经广泛应用于其他领域
生态系统(包括 Cosmos SDK)。

如果后来确实出现了一些无法与 gRPC 一起使用的用例，那也不会太
该应用程序作者难以编写一个小代理(在 Go 中)
将方便的 SDK API 桥接到比 gRPC 更简单的协议中。

**设计原则:** 不常见的特殊情况最好携带
其特殊性的负担，而不是在基础设施中烘烤逃生舱口。

**建议:** 我们应该弃用并删除套接字协议。

### RPC 传输选项

[ADR 057][adr-57] 提议将 gRPC 用于 Tendermint RPC 实现。
这仍然是可能的，但如果我们能够简化和解耦
如上所述，我认为没有必要。

虽然 JSON-RPC 不是所有情况下最好的 RPC 协议，但它具有
对于我们的域，gRPC 的一些优势。具体来说:

- 很容易从命令行手动调用 JSON-RPC，这有助于
  RPC 服务、本地调试和操作的常见问题。

  相关:JSON 对人类来说相对容易读写，而且它可以
  可以轻松复制和粘贴以共享示例查询和调试结果
  聊天、发表评论等。理想情况下，不会使用 RPC 服务
  对于文本协议的成本很重要的活动
  它的易读性和手动可用性优势。

- gRPC 对客户端和服务器都有巨大的依赖，并且
  它提供的许多功能来支持安全性和性能
  (加密、压缩、流媒体等)大多与本地无关
  利用。 Tendermint 已经需要为远程签名者包含一个 gRPC 客户端，
  但如果我们可以避免需要一个 _client_ 依赖 gRPC，那就是胜利
  为了可用性。

- 如果我们打算将轻客户端从 RPC 迁移到完全使用 P2P，则有
  沿途强制临时迁移到 gRPC 没有优势；还有一次
  轻客户端不依赖于RPC服务，效率
  协议没有那么重要。

- 我们仍然可以获得使用协议缓冲区生成数据类型的好处，即使
  不使用 gRPC:

  - Protobuf 为所有消息类型定义了标准的 JSON 编码，因此
    支持 protobuf 的语言不需要担心类型映射
    怪事。

  - 使用 JSON 意味着即使语言 _without_ 良好的 protobuf 支持也可以
    用更多的工作来实现协议，我希望这种情况
    少见。

即使一种语言缺乏良好的标准 JSON-RPC 机制，协议也是
轻量级，可以通过简单的发送/接收通过 TCP 或
Unix 域套接字，无需代码生成、加密等。 gRPC
使用复杂的基于 HTTP/2 的传输，不容易复制。

### 未来的工作

上面概述的背景和建议侧重于现有的结构
Tendermint 和我们可以在短期内做出的改进。值得
还应考虑对 IPC 生态系统进行更长期更广泛变化的选项。
以下概述了一些高层次的想法:

- **共识服务:** 今天，应用和共识节点
  名义上仅通过 ABCI 连接。 Tendermint 最初设计为
  与应用程序的所有通信都应该被中介的假设
  由共识节点。然而，根据进一步的经验，设计目标
  现在 _application_ 应该是应用程序状态的中介。

  然而，如上所述，ABCI 是一个客户端/服务器协议，具有
  应用程序作为服务器。对于结果证明是外部客户
  不错的选择，但它使应用程序和
  共识节点:以前交易是通过节点输入的，现在
  它们是通过应用程序输入的。

  我们已经通过使用 Tendermint RPC 服务来解决这个问题
  向共识节点应用“反向通道”，以便它可以推送
  交易回到共识网络。但是 RPC 服务暴露了一个
  还有许多其他功能，包括事件订阅、阻止和
  交易查询，以及大量的节点状态信息。

  即使我们不能轻易“固定”ABCI 关系的方向，我们
  可以通过拆分 RPC 服务的部分来改善隔离
  应用程序需要作为一个反向通道，并与 _only_ 共享那些
  应用。通过定义一个“共识服务”，我们可以给应用程序
  一种仅限于它需要的功能的回话方式。这种方法
  好处是我们可以在不破坏现有用途的情况下做到这一点，如果我们
  后来确实“修复”了 ABCI 方向性，我们可以放弃特殊情况
  不会中断 RPC 接口的其余部分。

- **事件服务:** 目前，IBC 中继器依赖于 Tendermint RPC
  提供区块和交易事件流的服务，它用于
  发现哪些交易需要中继到其他链。虽然我认为
  事件订阅最终应该通过 P2P 处理，我们可以获得
  通过将事件订阅与其余部分分开来获得一些直接的好处
  RPC 服务。

  在此模型中，事件订阅服务将向公众公开
  网络，但在不同的端点上。这将消除对 RPC 的需要
  支持 websocket 协议的服务，并允许运营商
  将潜在的敏感状态查询结果与公共网络隔离。

  目前中继者也使用 RPC 服务来获取区块数据
  同步，但工作已经在进行中以通过
  P2P 层。一旦完成，事件订阅就可以分开了。

分离现有 RPC 服务的各个部分并非没有代价:它可能
需要额外的连接端点，例如，虽然它也不太
多个其他独立的服务难以共享连接。

然而，作为回报，减少运输选择会变得更容易，并且
操作员独立控制对敏感数据的访问。考虑到
这些想法的可行性和影响超出了本 RFC 的范围，但是
它们被记录在此处，因为它们来自我们已经了解的背景
讨论。

## 参考

[abci]:https://github.com/tendermint/spec/tree/95cf253b6df623066ff7cd4074a94e7a3f147c7a/spec/abci
[rpc-service]:https://docs.tendermint.com/master/rpc/
[轻客户端]:https://docs.tendermint.com/master/tendermint-core/light-client.html
[tm-cli]:https://github.com/tendermint/tendermint/tree/master/cmd/tendermint
[cosmos-sdk]:https://github.com/cosmos/cosmos-sdk/
[本地客户端]:https://github.com/tendermint/tendermint/blob/master/abci/client/local_client.go
[套接字服务器]:https://github.com/tendermint/tendermint/blob/master/abci/server/socket_server.go
[sdk-grpc]:https://pkg.go.dev/github.com/cosmos/cosmos-sdk/types/tx#ServiceServer
[json-rpc]:https://www.jsonrpc.org/specification
[abci-conn]:https://github.com/tendermint/spec/blob/master/spec/abci/apps.md#state
[adr-57]:https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-057-RPC.md
