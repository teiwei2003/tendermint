# メモリプール

メモリプールは、潜在的に有効なトランザクションのメモリプールです。
他のノードにブロードキャストするだけでなく、他のノードにも提供します
ブロック提案者として選択された場合、コンセンサスリアクター。

メモリプールのステータスには、次の2つの側面があります。

-外部:新しいトランザクションを取得、確認、ブロードキャストします
-内部:有効なトランザクションを返し、ブロックが送信された後にリストを更新します

## 外部機能

外部機能はネットワークインターフェースを介して公開されます
信頼できない参加者へ。

-CheckTx-RPCまたはP2Pを介してトリガーします
-ブロードキャスト-チェックが成功した後のゴシップメッセージ

## 内部機能

内部関数は、メソッド呼び出しを通じて他の関数に公開されます
コードはtendermintバイナリファイルにコンパイルされます。

-ReapMaxBytesMaxGas-次のブロックで提案するtxsを取得します。確認
    txsのサイズはMaxBytes未満であり、ガスはMaxGas未満です。
-更新-最後のブロックに含まれるtxを削除します
-ABCI.CheckTx-ABCIアプリケーションを呼び出してtxを確認します

コンセンサスリアクターには何が提供されますか？
ABCIアプリケーションからどのような保証が必要ですか？
(並行性におけるインターリーブされたプロセスについて話します)

## 最適化

このライブラリの実装は、txキャッシングも実装します。
このように、txが持っている場合、署名を再検証する必要はありません
私は前にそれを見たことがあります。
ただし、有効なtxのみをキャッシュに保存し、無効なtxは保存しません。
これは、無効なtxが将来改善される可能性があるためです。
ブロックに含まれるTxは、キャッシュから削除されません。
それらはまだp2pネットワークを介して受信される可能性があるためです。
これらのトランザクションは、メモリの問題を軽減するためにハッシュを介してキャッシュに保存されます。

アプリケーションはリプレイ保護を実装する必要があります。[リプレイ
詳細については、保護](https://github.com/tendermint/tendermint/blob/8cdaa7f515a9d366bbc9f0aff2a263a1a6392ead/docs/app-dev/app-development.md#replay-protection)を参照してください。

## 構成

メモリプールには、さまざまな設定可能なパラメータがあります

誤ってコーディングされたデータまたは `maxMsgSize`を超えるデータを送信すると、
ピアを停止します。

`maxMsgSize`は、` MaxBatchBytes`(10MB)+ 4(プロトタイプのオーバーヘッド)に等しくなります。
`MaxBatchBytes`は、ローカルで定義されたメモリプール構成パラメータです。原子炉
接続されたピアにトランザクションをバッチで送信します。最大サイズ1
バッチ処理は `MaxBatchBytes`です。

メモリプールは、それを受信するピアにtxを送り返しません。

リアクタは、各ピアに「uint16」番号を割り当て、からの番号を維持します。
p2p.IDから `uint16`へ。各メモリプールトランザクションには、すべての送信者のリストが含まれています
( `[] uint16`)。リストは、メモリプールがトランザクションを受信するたびに更新されます
見たことあります。 `uint16`ノードに65535を超えるアクティブノードが存在しないと仮定します
ピア(0は、RPCなどの不明なソース用に予約されています)。
