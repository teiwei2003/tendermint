# Tendermintアーキテクチャの概要


> ** 2019年11月**

今後数週間で、@ brapse、@ marbar3778、および私(@tessr)は、TendermintCoreのアーキテクチャについて話し合うための一連の会議を開催します.これらは、これらの会議での私のメモです.これらは、将来のエンジニアエントリの成果物として機能するか、そのようなドキュメントの基礎を提供します.

## 伝える

Tendermint Coreでは、*ノード間通信*、*ノード内通信*、*クライアント通信*の3つの形式の通信(要求、応答、接続など)が発生する可能性があります.

-ノード間通信:ノードと他のピア間で発生します.この通信は、TCPまたはHTTPを介して実行されます.これについては、以下で詳しく説明します.
-ノード内通信:ノード内(つまり、reactorまたは他のコンポーネント間)で発生します.これらは通常、関数またはメソッドの呼び出しであるか、イベントバスを介して発生する場合があります.

-クライアント通信:クライアント(ウォレットやブラウザなど)とネットワークノード間で発生します.

### ノード間通信

ノード間の通信は、次の2つの方法で発生します.

1.p2pパケットを介したTCP接続
    -ノード間の通信の最も一般的な形式
    -ノード間の接続は、スイッチによって促進され、リアクター間で維持および共有されます. (スイッチの詳細については、以下をご覧ください.)
2. RPC over HTTP
    -短期間の1回限りのリクエスト用に予約済み
    -例:高さなど、原子炉の状態に固有
    -また可能:通知チャネルに接続されたWebソケット(例:新しいトランザクション)

### P2Pビジネス(スイッチ、PEX、名簿)

p2pサービスを作成する場合、2つの主な責任があります.

1.ルーティング:誰がどのメッセージを受信しますか？
2.ピア管理:誰と話すことができますか？彼らのステータスは何ですか？ピアディスカバリーをどのように実行しますか？

最初の責任はSwitchによって処理されます.

-ピア間の接続ルーティングを担当します
-_TCP接続のみを処理する_; RPC/HTTPは分離されていることに注意してください
-これは各reactorの依存関係です.すべてのreactorは関数 `setSwitch`を公開します.
-チャネル(TCP接続上のチャネル-Goチャネルではない)を保持し、ルーティングに使用します
-メッセージのグローバル名前空間を持つグローバルオブジェクトです
-libp2pと同様の機能

TODO:スイッチの実装に関する詳細情報(おそらく).

2番目の責任は、PEXと名簿の組み合わせによって処理されます.

 TODO:PEXと名簿とは何ですか？

#### TCPの本質と `mconnection`の導入

TCPに関するいくつかの関連する事実は次のとおりです.

1.すべてのTCP接続には、「信頼」に対するデータパケットのサイズを表す「フレームウィンドウサイズ」があります.つまり、新しい接続に沿ってデータパケットを送信する場合は、小さなデータパケットから開始する必要があります. .パケットが正常に受信されると、ますます大きなパケットの送信を開始できます. (この曲線は下の図に示されています.)これは、TCP接続の起動速度が非常に遅いことを意味します.
2. syn/ackプロセスは、小さくて頻繁なメッセージのオーバーヘッドが高いことも意味します
3.ソケットはファイル記述子で表されます.

！[tcp](../../imgs/tcp-window.png)

Tendermintで作成された条件下で高性能TCP接続を確立するために、「mconnection」または多重化接続を作成しました.これは、TCP上に構築された独自のプロトコルです. TCP接続を再利用してオーバーヘッドを最小限に抑え、必要に応じて補助メッセージを送信することでウィンドウサイズを高く保つことができます.

`mconnection`は、メッセージのバッチ、読み取りおよび書き込みバッファ、およびチャネルIDのリアクトルへのマッピングを含む構造で表されます.ファイル記述子を介してTCPと通信し、書き込むことができます.ピアツーピア接続ごとに1つのmconnectionがあります.

`mconnection`には2つのメソッドがあります.ソケットのrawハンドルを受け入れてそれに書き込む` send`と、別のバッファーに書き込む `trySend`です. (TODO:どのバッファー？)

`mconnection`は、(おそらく他の多くのピアと一緒に)ピアによって所有され、(グローバル)スイッチによって所有される(グローバル)トランスポートによって所有されます.

<!-- markdownlint-disable -->
```
switch
 transport
  peer
   mconnection
  peer
   mconnection
  peer
   mconnection
```
<!-- markdownlint-restore -->

## node.go

node.goは、ノードを実行するためのエントリポイントです.これは、reactorをセットアップし、スイッチを設定し、ノードのすべてのRPCエンドポイントを登録します.

## ノードタイプ


1.検証ノード:
2.フルノード:
3.シードノード:

TODO:ノードタイプとその設定方法の違いを詳しく説明してください.

## リアクター

ここにいくつかの原子炉の事実があります:

-各リアクトルには、グローバルスイッチへのポインタがあります( `SetSwitch()`で設定)
-スイッチは各リアクターへのポインターを保持します( `addReactor()`)
-各reactorはnode.goで設定されます(カスタムreactorを使用する場合は、これが指定する場所です)
-`addReactor`はスイッチによって呼び出されます; `addReactor`はこのreactorに対して` setSwitch`を呼び出します
-すべてのリアクターが以前に追加されたと仮定します
-場合によっては、リアクターはスイッチ(各リアクターへのポインターを維持する)を使用して、相互に通信するための相互参照を取得します. **質問:原子炉は他の方法で互いに通信できますか？ ****

さらに、すべての原子炉が露出しています.

1.TCPチャネル
2.`receive`メソッド
3.`addReactor`呼び出し

`receive`メソッドはmconnectionによって複数回呼び出すことができます.それはすべての原子炉で同じ署名を持っています.

`addReactor`は、reactorのすべてのチャネルでforループを実行し、チャネルID-> reactorマッピングを作成するために呼び出されます.スイッチはこのマッピングを維持し、TCP接続の薄いラッパーである_transport_に渡します.

以下は、網羅的な(？)リアクターリストです.

-ブロックチェーンリアクター
-コンセンサスリアクター
-証​​拠リアクター
-メモリープールリアクター
-PEXリアクター

これらのそれぞれについては、後で詳しく説明します.
