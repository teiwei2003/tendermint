# ADR 067:メモリプールの再構築

-[ADR 067:メモリプールのリファクタリング](#adr-067-mempool-refactor)
  -[変更ログ](#changelog)
  -[状態](#State)
  -[コンテキスト](#context)
    -[現在のデザイン](#current-design)
  -[代替方法](#alternative-approaches)
  -[既存のテクノロジー](#prior-art)
    -[イーサリアム](#ethereum)
    -[Diem](#diem)
  -[決定](#decision)
  -[詳細設計](#detailed-design)
    -[CheckTx](#checktx)
    -[メモリプール](#mempool)
    -[Eviction](#eviction)
    -[八卦](#八卦)
    -[演](#演)
  -[将来の改善](#future-improvements)
  -[結果](#consequences)
    -[正](#positive)
    -[ネガティブ](#ネガティブ)
    -[ニュートラル](#neutral)
  -[参照](#references)

## 変更ログ

-2021年4月19日:最初のドラフト(@alexanderbez)

## ステータス

受け入れられました

## 環境

Tendermint Coreには、リアクターとデータ構造のmempoolがあり、これが役立ちます。
コミットされていないトランザクションの一時的な保存。参加している正直なノード
Tendermintネットワークは、これらのコミットされていないトランザクションが相互にゴシップする場合、
アプリケーションの `CheckTx`を介して。さらに、からのブロック提案者
メモリプールには、コミットされていないトランザクションのサブセットが次のブロックに含まれます。

現在、TendermintCoreのmempoolはFIFOキューとして設計されています。他の
つまり、トランザクションは、ノードによって受信されたときにブロックに含まれます。三
現在、これらのコミットされていないトランザクションの明確で優先順位はありません。
これは、オペレーターとアプリケーションにいくつかの技術的およびユーザーエクスペリエンスの課題をもたらします。

言い換えれば、バリデーターは彼らの料金や
インセンティブと調整メカニズム。さらに、優先順位の欠如はまたにつながります
DoSおよびネットワーク上のさまざまな攻撃ベクトルに対するカスケード効果、
たとえば、[cosmos/cosmos-sdk#8224](https://github.com/cosmos/cosmos-sdk/discussions/8224)です。

したがって、Tendermint Coreでは、アプリケーションとそのユーザーが次のことができるようにする必要があります。
柔軟で効率的な方法でトランザクションに優先順位を付けます。具体的には、
以下の属性を改善、維持、または追加することを目的としています
テンダーミントメモリープール:

-アプリケーションがトランザクションの優先度を決定できるようにします。
-効率的な同時読み取りと書き込みを可能にします。
-ブロック提案者が優先度によってトランザクションを効率的に取得できるようにします。
-トランザクションサイズに基づいて固定メモリプール容量を維持し、優先度を低くします
  優先度の高いトランザクションのための余地を作ります。
-優先度による効率的なゴシップトランザクションを可能にします。
-オペレーターが前にメモリープール内のトランザクションの最大TTLを指定できるようにする
  ブロックプロポーザルが時間内に選択されない場合、それらは自動的に削除されます。
-設計が優先順位の置き換えなどの将来の拡張を可能にすることを確認します。
  各送信者が複数の保留中のトランザクションを持つことを許可します。これは簡単にマージできます。

これらのプロパティのすべてが提案された変更で解決されるわけではないことに注意してください
このADR。ただし、提案は未解決のプロパティを保証します
将来的には、シンプルでスケーラブルな方法で解決できます。

### 現在のデザイン

！[mempool](./ img/mempool-v0.jpeg)

`v0`メモリプールリアクタのコアは、同時リンクリストです。これは
「CheckTx」を通過した「Tx」オブジェクトのメインデータ構造が含まれます。
ノードが別のノードからトランザクションを受信すると、「CheckTx」を実行します。
`* CListMempool`の読み取りロックを取得します。トランザクションが `CheckTx`に合格した場合
ノードのローカルで、書き込みロックを取得して `* CList`に追加します。それ
`cache`と` txsMap`にも追加されました。どちらも独自のものを持っています
ロックを書き込み、トランザクションハッシュの参照を「Tx」自体にマップします。

新しいトランザクションが追加されるたびに、トランザクションはピアに継続的に送信されます
ローカルノードの「* CList」に対して、「* CList」より前のノードを選択します。
`* CList`がリーダーに通知する前に、別のトランザクションはゴシップされません
ゴシップにはもっと多くの取引があります。

提案者がブロックを提案しようとすると、 `ReapMaxBytesMaxGas`が実行されます。
リアクターの `* CListMempool`について。この呼び出しは、 `* CListMempool`の読み取りロックを取得します
そして、 `* CList`の前からできるだけ多くのトランザクションを選択します
リストの最後に移動します。

ブロックが最終的に送信されると、呼び出し元はリアクターで「更新」を呼び出します
`* CListMempool`には、選択したすべてのトランザクションが含まれます。発信者も
リアクタの `* CListMempool`の書き込みロックを明示的に取得します。この呼び出し
提供されたすべてのトランザクションは、 `txsMap`と` * CList`から削除されます。どちらも
それぞれの書き込みロックを取得します。さらに、トランザクション
独自の書き込みロックを取得する「キャッシュ」から削除することもできます。

## 代替方法

優先度ベースの柔軟性を実現するために採用する方法を検討し、
高性能メモリプールには2つのコア候補があります。最初の候補者が少ない
必要なプロトコルと実装の変更のセットに侵入します。
既存の `CheckTx`ABCIメソッドを拡張するだけです。 2番目の候補は本質的に
新しいABCIメソッドの導入を含み、より高度な学位を必要とします
プロトコルと実装の複雑さが変化し、その一部は
今後の[ABCI ++](https://github.com/tendermint/spec/blob/master/rfc/004-abci%2B%2B.md)と重複または競合します。

さまざまな方法と推奨事項の詳細については、を参照してください。
[メモリプールディスカッション](https://github.com/tendermint/tendermint/discussions/6295)。

## 現在のテクノロジー

### イーサリアム

イーサリアムメモリプール、特に[Geth](https://github.com/ethereum/go-ethereum)、
アカウントによってインデックス付けされたさまざまなマッピングを含むメモリプール `* TxPool`が含まれています。
たとえば、「保留中」には、アカウントで処理できるすべてのトランザクションが含まれます
ノンスによる優先順位。また、まったく同じマッピングである「キュー」も含まれています
現在処理できないトランザクションが含まれている場合を除きます。メモリープールも
優先キューに基づくタイプ「* txPricedList」の「価格設定」インデックスが含まれています
取引価格で。

### 薄暗い

[Diemメモリプール](https://github.com/diem/diem/blob/master/mempool/README.md#implementation-details)
推奨する方法と同様の方法が含まれています。具体的には、Diemメモリプール
`Account:[] Tx`からのマッピングが含まれています。アカウントからのこのメインマッピングに加えて
トランザクションリストには、特定の操作を実行するために使用されるさまざまなインデックスがあります。

プライマリインデックス、 `PriorityIndex`。順序付けられたトランザクションキューです
「コンセンサスレディ」(つまり、シリアル番号が
アカウントの現在のシリアル番号)。このキューはガス価格でソートされています
顧客が(他の顧客よりも)ユニットあたりより多く支払うことをいとわない場合
実装すれば、彼らはより早く合意に達することができます。

## 決定

優先度ベースの柔軟で高性能なメモリプールをTendermintCoreに追加するために、
`ResponseCheckTx`に新しいフィールド` priority`と `sender`を導入します
タイプ。

メモリプールリアクタの新しいバージョンである `v1`を導入し、暗黙的なものを想定します
現在のメモリプールリアクタのバージョンは「v0」です。新しい「v1」メモリプールリアクタでは、
最下層を増やすことを除いて、 `v0`と同じ機能を大幅に維持します
データ構造。具体的には、送信者からトランザクションオブジェクトへのマッピングを維持します。
このマッピングに加えて、効果的なサービスを提供するためにトランザクションにインデックスを付けます
ゴシップと取引の優先順位付け。

## 詳細設計

### CheckTx

`ResponseCheckTx`タイプに次の新しいフィールドが導入されました。

```diff
message ResponseCheckTx {
  uint32         code       = 1;
  bytes          data       = 2;
  string         log        = 3;  // nondeterministic
  string         info       = 4;  // nondeterministic
  int64          gas_wanted = 5 [json_name = "gas_wanted"];
  int64          gas_used   = 6 [json_name = "gas_used"];
  repeated Event events     = 7 [(gogoproto.nullable) = false, (gogoproto.jsontag) = "events,omitempty"];
  string         codespace  = 8;
+ int64          priority   = 9;
+ string         sender     = 10;
}
```


これらのフィールドへの入力方法を決定するのは、完全にアプリケーション次第です。
そして、たとえば「送信​​者」が署名者と支払者になることができる値
トランザクションでは、「優先度」は手数料の累積額になります。

`sender`のみが必要であり、` priority`は省略できます。
デフォルト値のゼロを使用します。

### メモリプール

既存の同時セーフリンクリストは、スレッドセーフマッピングに置き換えられます
`<sender:* Tx>`、つまり、 `sender`から単一の` * Tx`オブジェクトへのマッピング。
各 `* Tx`は、指定された` sender`からの次の有効で処理可能なトランザクションです。

このマッピングに加えて、スレッドセーフな方法を使用して、すべてのトランザクションを優先度でインデックス付けします
優先キュー、つまり[最大ヒープ](https://en.wikipedia.org/wiki/Min-max_heap)。
提案者が次のブロック提案のトランザクションを選択する準備ができたら、
優先度の高い順にトランザクションを優先度インデックスから選択します。
トランザクションが選択されて収集されると、このインデックスから削除され、
`<sender:* Tx>`マッピングから。

`Tx`を次のデータ構造として定義します。

```go
type Tx struct {
  // Tx represents the raw binary transaction data.
  Tx []byte

  // Priority defines the transaction's priority as specified by the application
  // in the ResponseCheckTx response.
  Priority int64

  // Sender defines the transaction's sender as specified by the application in
  // the ResponseCheckTx response.
  Sender string

  // Index defines the current index in the priority queue index. Note, if
  // multiple Tx indexes are needed, this field will be removed and each Tx
  // index will have its own wrapped Tx type.
  Index int
}
```

### 国外追放

新しい「Tx」に対して「CheckTx」を正常に実行した後、メモリプールは現在
満杯の場合、削除できる優先度の低い「Tx」があるかどうかを確認する必要があります
優先度が高く、十分なサイズの新しい「Tx」用のスペースを確保します
残りの容量。

そのような `Tx`がある場合、読み取りロックを取得してソートすることでそれを見つけます
優先キューインデックス。並べ替え後、優先度の低い最初の「Tx」が見つかり、次に
新しい「Tx」がメモリプールのサイズ制限に合うようにサイズを設定します。その後、私たちは
この `Tx`と` <sender:* Tx> `を優先キューインデックスから削除します
マッピング。

これには、追加の「O(n)」スペースと「O(n * log(n))」ランタイムの複雑さが必要になります。スペースの複雑さはtxのサイズに依存しないことに注意してください。

### ゴシップ

既存のスレッドセーフリンクリストを追加のインデックスとして保持します。これを使って
インデックス、私たちはそれらと同じ方法で効果的にゴシップトランザクションを行うことができます
今ゴシップ(FIFO)。

ゴシップトランザクションは、他のインデックスをロックする必要はありません。

### パフォーマンス

スペースのオーバーヘッドに加えて、パフォーマンスはほとんど影響を受けないはずです
追加の優先キューインデックスと、削除する必要のある状況を保持します
優先キューインデックスからのトランザクション。読むべきではない
任意のインデックスへの書き込みをブロックする

## 将来の改善

提案された設計を改善または改善するためのいくつかの重要な方法があります
拡張されました。つまり、ゴシップとサポートを交換する能力
同じ「送信者」からの複数のトランザクション。

ゴシップの取引については、経験から確認する必要があります。
ゴシップを優先する必要があります。さらに、現在のゴシップメソッドはそうではないかもしれません
最も効率的になります。具体的には、ノードのすべてのトランザクションをブロードキャストします
メモリプールに対応するものがあります。代わりに、機能を調査する必要があります
要求/応答に基づくゴシップトランザクションは、イーサリアムなどに似ています
プロトコル。これにより、帯域幅と複雑さが軽減されるだけでなく、
優先順位やその他の側面でゴシップをより効果的に探求できるようにするためです。

同じ「送信者」からの複数のトランザクションを許可することは重要であり、
将来のメモリープール開発に必要な機能かもしれませんが、
今のところ、予備設計に同意するだけで十分です。できる
「送信者」ごとに複数のトランザクションをサポートするには、慎重に検討する必要があります
対応するABCIアプリケーションの相互作用について。とにかく、
提案された設計では、この機能をサポートするための調整が可能である必要があります
物議を醸す下位互換性のある方法。

## 結果

### ポジティブ

-アプリケーションがトランザクションに優先順位を付けることを許可します。

### ネガティブ

-`ResponseCheckTx`プロトコルバッファタイプのサイズを増やしました。
-因果関係を維持しません。
  -特定の順序でブロードキャストされる特定のトランザクションは、
  `CheckTx`に合格しましたが、失敗したためブロックでコミットしませんでした
  後で `CheckTx`。たとえば、既存のTx <sub> 1 </ sub>から資金を送ることを検討してください。
  アカウントアリスは優先度P <sub> 1 </ sub>の_新しい_アカウントボブに行き、その後
  ボブの_new_アカウントは、Tx <sub> 2 </ sub>とP <sub> 2 </ sub>でアリスに資金を送り返します。
  P <sub> 2 </ sub >> P <sub> 1 </ sub>にします。この順序で実行すると、両方
  トランザクションは `CheckTx`を通過します。しかし、提案者が選択する準備ができたら
  次のブロック提案トランザクションでは、前にTx <sub> 2 </ sub>を選択します
  Tx <sub> 1 </ sub>はTx <sub> 1 </ sub>でなければならないため、Tx <sub> 1 </ sub>とTx <sub> 2 </ sub>は_失敗_します
  最初に実行されます。これは、_因果シーケンス_があるためです。
  Tx <sub> 1 </ sub>→Tx <sub> 2 </ sub>。これらのタイプの状況はまれであるはずです。
  ほとんどのトランザクションは因果関係がなく、簡単に回避できます
  後で再試行するか、「子」の優先順位が
  「親」の優先度よりも低い。言い換えれば、親が常に持っている場合
  子供よりも優先度が高い場合、新しいメモリプールの設計は
  原因と結果の順序を維持します。

### ニュートラル

-`CheckTx`を通過してメモリプールに入るトランザクションは、後で削除できます
  将来のある時点で、
  メモリプールがいっぱいです。

## 参照する

-[ABCI ++](https://github.com/tendermint/spec/blob/master/rfc/004-abci%2B%2B.md)
-[メモリプールディスカッション](https://github.com/tendermint/tendermint/discussions/6295)
