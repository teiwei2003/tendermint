# ADR 015:暗号化コード

## 環境

チェーン上で公開鍵と署名をエンコードする方法を標準化する必要があります.
現在、公開鍵と署名をアミノ基でエンコードしています.
ここでアミノを使用する理由は、主にサポートのしやすさのためです
他の言語を解析します.
暗号化システムでのアップグレード性は必要ありません.
調整が必要な暗号化された通貨は、考慮する必要がある場合があります
新しいパスワードシステム.
(つまり、新しいパブリックパラメータを使用します)

## 決定

### 公開鍵

公開鍵については、仕様に引き続きアミノコードを使用します
公開鍵の表現.
(暗号化システム自体によって定義された仕様)
これには2つの明らかな欠点があります.
スケーラビリティをサポートする必要があるため、アミノコーディングのスペース効率は低くなります.
アミノエンコーディングサポートは、protobufをフォークし、この新しいインターフェイスサポートを追加する必要があります
選択した言語のオプション.

しかし、アミノを使い続ける理由は、人々がコードを作成できるからです
すでに最新のアミノライブラリを持っている言語の方が簡単です.
これは、考慮された場合、将来変更される可能性があります
Tendermint暗号化と相互作用するためにアミノは必要ありません.

ここでのスペース効率の議論は、その理由で反論されています
SDKのスペースの浪費ははるかに深刻です.
公開鍵のスペース要件は多くの問題を引き起こしません
各バリデーター/アカウントに接続するスペースを増やします.

ここでアミノを使用する代わりに、列挙型を作成することもできます.
列挙型への切り替えは、公開後に調査する価値があります.
参考までに、アミノエンコーディングインターフェイスの一部は基本的に4バイトの列挙です
タイプ定義.
列挙型は、これらの4バイトのみをバリアントに変更して削除します
protobufはオーバーヘッドですが、既存のAPIに統合することは困難です.

### サイン

署名は `[] byte`に切り替える必要があります.
署名のスペース効率は非常に重要ですが、
各トランザクションのガスコストに直接影響するため、
そしてチェーンのスループット.
署名はそのタイプをエンコードする必要はありません(公開鍵とは異なります)
公開鍵を知っている必要があるからです.
したがって、タイプをエンコードせずに署名を検証できます.

状態に置かれた場合、署名は引き続きアミノエンコードされますが、
プリミティブ型 `[] byte`がエンコードされます.

#### Ed25519

署名の正規表現を使用します.

#### Secp256k1

ここには明確な仕様はありません.
署名には2つの要素 `r、s`があります.
これらのバイトは `r || s`としてエンコードされます.ここで、` r`と `s`は両方とも
32バイト長のビッグエンディアンエンコーディング.
これは基本的にイーサリアムのエンコーディングですが、主要なリカバリビットはありません.

## ステータス

実装

## 結果

### ポジティブ

-より多くの省スペース署名

### ネガティブ

-暗号化にアミノ依存性があります.

### ニュートラル

-公開鍵の変更はありません
