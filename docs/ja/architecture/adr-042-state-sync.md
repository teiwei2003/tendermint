# ADR 042:状態同期設計

## 変更ログ

2019-06-27:EB開始
2019-07-04:ブラプスフォローアップ

## 環境
StateSyncは、新しいノードが受信できるようにするアイテムです
アプリケーションの状態のスナップショット。ブロックをダウンロードしたり、移動したりする必要はありません。
コンセンサスを通じて。ダウンロード後、ノードはFastSyncに切り替えることができます
そして最後にコンセンサスに参加します。 StateSyncの目標は
できるだけ早く新しいノードの確立を促進します。

## 予防
Tendermintはアプリケーションの状態について何も知らないため、
StateSyncはノード間でメッセージをプロキシし、パスします
不透明なアプリケーションへのABCI。複数あります
TendermintコードベースおよびABCIアプリケーションのタッチポイント。

*ピアツーピア通信を容易にするStateSyncリアクター-Tendermint
*アプリケーションステータスをreactorに転送するために使用される一連のABCIメッセージ-Tendermint
*スナップショットデータをABCI-ABCIアプリケーションに公開するためのMultiStoreAPIのセット
*検証とパフォーマンスを考慮したストレージフォーマット-ABCIアプリケーション

### 実装属性
メソッドに加えて、StateSyncの任意の実装を評価できます
さまざまな基準にわたって:

*速度:本番および消費のスナップショットの予想スループット
*セキュリティ:無効なスナップショットをノードにプッシュするコスト
*活性:ノードがスナップショットを受信/構築できないようにするためのコスト
*努力:実現にはどれだけの努力が必要か

### 実装の問題
*スナップショットの形式は何ですか
    *完全なスナップショット
    *注文したIAVLキー範囲
    *検証可能な個別に圧縮されたブロック
*データを確認する方法
    *ピアのデータを盲目的に信頼する
    *私は私の仲間のほとんどを信じています
    *ライトクライアント検証を使用して、各ブロックがコンセンサスを満たしているかどうかを検証します
      メルケルのルーツを生成する
*パフォーマンス特性は何ですか
    *ランダムおよびシーケンシャルリーディング
    *スケジューリングアルゴリズムはどの程度並列ですか

### 提案
大まかに言えば、この問題を解決するには2つの方法があります
さまざまなレベルの議論と進歩。これらのメソッドは
要約すると:

**怠惰:**要求されたときにスナップショットを動的に生成する場所。この
このソリューションでは、既存のデータ構造を使用します。
**熱心な:**スナップショットが定期的に生成され、サービスがディスクから提供される場所
リクエスト時間。このソリューションは、補助データ構造を作成します
バッチ読み取り/書き込み用に最適化されています。

さらに、提案はセキュリティをどのように提供するかによって異なることがよくあります
特性。
** LightClient **ここで、クライアントはブロックからメルケルルートを取得できます
信頼できるバリデーターセットから同期されたヘッダー。アプリケーション状態のサブセット、
したがって、着信時に呼び出されたブロックを検証して、各ブロックを確認できます。
メルケルルートの一部です。

**ほとんどのピアノード**ブロックリストとチェックサムはどこにありますか
ダウンロードして、ほとんどの提供バージョンと比較します
ピア。

#### レイジー状態の同期
元の仕様はAlexisSellierによって公開されました。
この設計では、状態には特定の元の要素「サイズ」があります(例:
キーまたはノード)、各要素には0から `size-1`までの番号が割り当てられます。
ブロックは、そのような一連の要素で構成されます。アクラトスが提案した
[いくつかの懸念](https://docs.google.com/document/d/1npGTAa1qxe8EQZ1wG0a0Sip9t5oX2vYZNUDwr_LVRR4/edit)
この設計に関しては、IAVLツリーに少し固有です。主に
ツリーをランダムに読み取り、トラバースして、要素番号のパフォーマンスを判断します
(つまり、要素は要素番号でインデックス付けされません)。

ジェクォンは別のデザインを提案しました
[#3639](https://github.com/tendermint/tendermint/issues/3639)ブロックされた場所
遅延的かつ動的に発生します。ノードはピアにキー範囲を要求します。
そして、ピアはいくつかのサブセットで応答します
リクエストの範囲と、残りを他の人に並行してリクエストする方法に関する指示
ピア。ブロック番号とは異なり、キーは直接確認できます。いくつかのキーが入っている場合
スコープを省略した場合、スコープの証明は検証できません。
このようなノードは、ツリー全体を要求するノードから開始できます。
そして、ピアは最初のいくつかのキーと要求される範囲で応答できます
他の同僚から。

さらに、各ブロックの検証はより自然になる傾向があります
ツリーの既存の構造を使用する傾向があるため、レイジーアプローチ
(つまり、キーまたはノード)状態同期固有のブロックの代わりに。そのような
テンダーミントのデザインはもともと
[#828](https://github.com/tendermint/tendermint/issues/828)。

####熱心なStateSync
OpenEthereumに実装されたワープ同期は高速です
ピアからブロックと状態のスナップショットをダウンロードします。データは最大4MBに分割されます
チャンクと活気のある圧縮。きびきびとした圧縮ブロックのハッシュは、
調整されたステータス同期マニフェストファイル。正しいリストを取得する
ドキュメントには、正直な大多数の同僚が必要なようです。これはあなたが見つけられないかもしれないことを意味します
コンテンツ全体をダウンロードして比較するまで、ステータスは正しくありません
検証済みのブロックヘッダー付き。

Binanceは同様のソリューションを実装しました
[#3594](https://github.com/tendermint/tendermint/pull/3594)
彼らが何であるかに基づいて
[PR#3243](https://github.com/tendermint/tendermint/pull/3243)
そして[いくつかの学習](https://docs.google.com/document/d/1npGTAa1qxe8EQZ1wG0a0Sip9t5oX2vYZNUDwr_LVRR4/edit)。
これには、正直な多数決の同等性の仮定が必要であることに注意してください。

緊急のプロトコルとして、warp-syncはより大きくより多くを効果的に圧縮できます
各スナップショットは予測可能なブロックであり、多くの新しいピアにサービスを提供します。通過する
レイジーブロッカーは、要求に応じて各ブロックを圧縮する必要があります
時間。

### 怠惰と欲望の分析
LazyとEagerには、違いよりも共通点があります。それらはすべて必要です
ミント側のリアクター、ABCIメッセージのセットとメソッド
SnapshotFormatは、スナップショットのシリアル化/逆シリアル化を容易にします。

怠惰な提案と熱心な提案の最大の違いは
スナップショットブロックに必要な読み取り/書き込みモードを提供します。
具体的には、Lazy State Syncは、基になるデータのランダムな読み取りを実行します
構造、および熱心な人は、順次読み取りを最適化できます。

Binanceの調査は、このアプローチの違いを証明しています
[レイジー]の[ackratos](https://github.com/ackratos)
状態の同期](https://github.com/tendermint/tendermint/pull/3243)、
[分析](https://docs.google.com/document/d/1npGTAa1qxe8EQZ1wG0a0Sip9t5oX2vYZNUDwr_LVRR4/)
[Warp]のパフォーマンスとフォローアップの実装
同期](http://github.com/tendermint/tendermint/pull/3594)。

#### 比較セキュリティモデル
いくつかの異なるセキュリティモデルがあります
過去に議論・提案されてきましたが、通常は2つのカテゴリーに分けられます。

軽いクライアント検証:データを受信するノードが期待される場所
最初に軽いクライアント同期を実行し、必要なすべてのブロックを用意します
タイトル。信頼できるブロックヘッダー内(信頼の観点から)
バリデーターの設定は[weak
主観性](https://github.com/tendermint/tendermint/pull/3795))および
ブロックと呼ばれるキーのサブセットは、メルケルルートと比較できます。
ライトクライアント検証の利点は、ブロックヘッダーが
検証者によって署名されたこれらの検証者は、悪意を持って何かを失います
行動。ベリファイアが無効な証明を提供する場合、
減らす。

ほとんどのピア検証:ブロックリストを含むマニフェストファイル
からの各ブロックのチェックサムと一緒に
信頼できるソース。ソースは、次のようなコミュニティリソースにすることができます
[sum.golang.org](https://sum.golang.org)またはほとんどからダウンロード
同い年の。ほとんどのピアツーピアセキュリティモデルの欠点の1つは、
悪意のあるユーザーが予期していた攻撃を覆い隠す
ターゲットノードのピアリストを飽和させて生成します
多くの。

3番目のオプションは、スナップショット関連のデータをに含めることです。
かさばる。これには、関連するチェックサムのリストが含まれる場合があります。
コンセンサスによって保証されます。このアプローチの1つの課題は
スナップショットを作成しても、ブロックに元に戻る負担がかからないようにしてください
スナップショットの作成とブロックの作成を同期することでサポートされます。 1
負担を最小限に抑える方法は、高さのスナップショットを撮ることです
`H`はブロック` H + n`に含まれています。ここで、 `n`はいくつかの` n`ブロックです。
ブロックプロッパーにスナップショットを完了するのに十分な時間を与えます
非同期。

## 提案:熱心なStateSyncと各ライトクライアントの検証
長所と短所を包括的に検討した後に導き出された結論
緊急性/怠惰とさまざまなセキュリティモデルが状態の同期を生成しています
スナップショットを熱心に生成し、軽いクライアント認証を使用します。この
この方法には、事前計算と高効率というパフォーマンス上の利点があります。
スナップショットは、シーケンシャルIOを使用してオンデマンドで新しいノードにストリーミングできます。
次に、ライトクライアント認証を使用することで、各ブロックを検証できます
潜在的なピアベースの日食攻撃のほとんどを受け取り、回避する
安全性。

### 埋め込む
Tendermintは、ダウンロードと検証を担当します
ピアからのAppState。 ABCIアプリは取る責任があります
TMからAppStateChunkオブジェクトを作成し、有効な状態ツリーを構築します。
ルートは、同期されたブロックのAppHashに対応します。特に私たち
実装する必要があります:

*プロキシノード間のメッセージ送信用に新しいStateSyncリアクタを構築する
  そしてABCIアプリ
* ABCIメッセージのグループ
*スナップショットフォーマットをインターフェースとして設計します。次のことができます。
    *検証ブロック
    *ファイルからのブロックの読み取り/書き込み
    *アプリケーション状態ストレージとの間のブロックの読み取り/書き込み
    *リストをchunkRequestABCIメッセージに変換します
* cosmos-hubのSnapshotFormatを実装します。具体的な実装は次のとおりです。
    *ブロックの読み取り/書き込み方法は次のとおりです。
        *ピア間で並列
        *受領時に確認する
    * IAVL +ツリーからの読み取り/書き込み/

！[StateSyncアーキテクチャ図](img/state-sync.png)

## 気付く
* [#3753](https://github.com/tendermint/tendermint/pull/3753)に基づいてStateSyncリアクターを作成します
* cosmos-hub実装設計に焦点を当てるSnapshotFormat
* SnapshotFormatを送受信するABCIメッセージ
* IAVL +がSnapshotFormatをサポートするように変更されました
*ワープ同期を提供します(ブロック検証なし)
*弱く主観的なライトクライアントの実装
* StateSyncにブロック検証を提供する

## ステータス

提案

## 結果として

### ニュートラル

### ポジティブ
*安全で高性能な状態同期設計は、実際の実装経験に基づいています
*汎用インターフェースにより、アプリケーション固有のイノベーションが可能になります
*合理的なエンジニアリング作業を通じて、並列化可能な実装軌道を実現します

### ネガティブ
*静的スケジューリングには、リアルタイムのブロック可用性最適化の機会がありません

## 参照する
[同期:現在の状態を同期します。アプリケーションを完全に再生する必要はありません](https://github.com/tendermint/tendermint/issues/828)-元の問題
[テンダーミントステータス同期提案2](https://docs.google.com/document/d/1npGTAa1qxe8EQZ1wG0a0Sip9t5oX2vYZNUDwr_LVRR4/edit)-ackratos提案
[提案2の実装](https://github.com/tendermint/tendermint/pull/3243)-ackratosの実装
[WIP General/Lazy State-Sync pseudo-specification](https://github.com/tendermint/tendermint/issues/3639)-Jaeの提案
[ワープ同期の実装](https://github.com/tendermint/tendermint/pull/3594)-ackratos
[チャンク提案](https://github.com/tendermint/tendermint/pull/3799)-バッキー提案
