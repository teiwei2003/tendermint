# ADR 019:マルチシグニチャのコーディング標準

## 変更ログ

2018年6月8日:小さな更新

27-07-2018:アミノコードを使用するようにドラフトを更新

2018年11月7日:最初のドラフト

2021年5月26日:MultisigはCosmos-sdkに移動されました

## 環境

マルチシグニチャ、または技術的には_Accountable Subgroup Multisignatures_(ASM)、
署名者のグループの任意のサブグループが任意のメッセージに署名できるようにする署名スキームです。
そして、署名者の正確な身元を検証者に明らかにします。
これにより、署名を検証するタイミングの複雑な条件が可能になります。

署名者セットのサイズが_n_であると仮定します。
署名を確認する場合、サイズ_k_のサブグループがメッセージに署名すると、
これは、ビットコインで一般にnマルチ署名と呼ばれる_kのコンテンツになります。

このADRは、サブグループのマルチシグニチャを一般的に担当するコーディング標準を規定しています。
nは、サブグループのマルチシグニチャのkと、それらの重み付けされたバリアントを担当します。

将来的には、説明責任のあるサブグループに対してより複雑な条件を許可することもできます。

## 推奨される解決策

### 新しい構造

次に、各ASMは独自の構造を持ち、crypto.Pubkeyインターフェイスを実装します。

このADRは、[crypto.Signatureを[]バイトに置き換える](https://github.com/tendermint/tendermint/issues/1957)を受け入れたと見なされます。

#### K個のN個のしきい値シグネチャ

公開鍵の構造は次のとおりです。

```golang
type ThresholdMultiSignaturePubKey struct { // K of N threshold multisig
	K       uint               `json:"threshold"`
	Pubkeys []crypto.Pubkey    `json:"pubkeys"`
}
```

公開鍵の長さからNを導き出します。 (コーディングスペース効率のため)

`Verify`には、` [] byte`でエンコードされたマルチシグニチャが必要です。
(マルチシグニチャについては次のセクションで説明します)
ビットマップのインデックスがk未満の場合、マルチシグニチャは拒否されます。
または、k個のインデックスのいずれかの署名が
メッセージ内のk番目の公開鍵。
(kを超える署名が含まれている場合は、すべての署名が有効である必要があります)

`Bytes`は、公開鍵のアミノエンコードバージョンになります。

アドレスは `Hash(amino_encoded_pubkey)`になります

これがすべての署名者に `log_8(n)`バイトを使用しない理由は、非常に少数の署名者を必要とする状況に合わせて大幅に最適化されているためです。
たとえば、サイズが「24」の「n」の場合、「k <3」の場合、これはスペースを節約するだけです。
これはありそうもないようであり、この状況に合わせて最適化するべきではありません。

#### 加重しきい値シグネチャ

公開鍵の構造は次のとおりです。

```golang
type WeightedThresholdMultiSignaturePubKey struct {
	Weights []uint             `json:"weights"`
	Threshold uint             `json:"threshold"`
	Pubkeys []crypto.Pubkey    `json:"pubkeys"`
}
```

ウェイトとパブキーの長さは同じでなければなりません。
他のすべては、NマルチシグニチャのKと同じです。
重みの合計がしきい値よりも小さい場合、マルチシグニチャは失敗します。

#### マルチシグニチャ

署名の中間段階(より多くの署名が生成されるため)は、次の構造になります。

```golang
type Multisignature struct {
	BitArray    CryptoBitArray // Documented later
	Sigs        [][]byte
```

各秘密鍵は、提供されたメッセージ自体に署名を出力することを覚えておくことが重要です。
したがって、署名アルゴリズムは複数の署名を出力しません。
UIは署名を受け入れ、マルチ署名に変換してから、追加を続けます
新しい署名を追加し、完了後に `[] byte`にグループ化します。
これには、次の補助メソッドが必要になります。

```golang
func SigToMultisig(sig []byte, n int)
func GetIndex(pk crypto.Pubkey, []crypto.Pubkey)
func AddSignature(sig Signature, index int, multiSig *Multisignature)
```

マルチシグニチャは、amino.MarshalBinaryBareを使用して `[]バイト`に変換されます。 \ *

#### ビット配列

ビット配列の新しい実装を使用します。 エンコード/デコードされる構造は次のとおりです。

```golang
type CryptoBitArray struct {
	ExtraBitsStored  byte      `json:"extra_bits"` // The number of extra bits in elems.
	Elems            []byte    `json:"elems"`
}
```

現在 `libs/common/bit_array.go`に実装されているBitArrayを使用しない理由
スペースと時間のトレードオフのため、スペース効率は低くなります。
[この問題](https://github.com/tendermint/tendermint/issues/2077)は、この点に関する証拠を要約しています。

マルチシグニチャでは、算術演算を実行しません。
したがって、現在の実装ではパフォーマンスの向上はありません。
スペース効率の低下にすぎません。
この新しいビット配列を `[] byte`で実装するのは非常に簡単なはずです。なぜなら、
ビット配列間の算術演算が必要で、数バイトを節約します。
(同じ質問で説明されています)

このビット配列がコード化されると、要素の数はアミノ基によってコード化されます。
ただし、実際には1〜7ビットしか必要としないコンテンツのフルバイトをエンコードしている場合があります。
この違いをExtraBitsStoredに保存します。
これにより、署名者の数に制限がなくなり、現在 `libs/common`で使用されているスペースよりも多くのスペースを節約できます。
繰り返しになりますが、この省スペース機能の実現は簡単です。

### コーディング構造

直接アミノコーディングを使用します。このオプションは、他の言語との互換性のために選択されています。

###今後の議論のポイント

必要に応じて、すべてのed25519キーにed25519バッチ検証を使用できます。
これは将来の議論のポイントですが、この情報をグループ化する必要がないため、下位互換性があります。
(リストレットがない場合は、補因子の問題さえあるかもしれません)
Schnorr sigs/BLSsigsの公開鍵/ sigs集約は下位互換性がなく、新しいASMタイプである必要があります。

## ステータス

実装(cosmos-sdkに移動)

## 結果

### ポジティブ

-マルチシグニチャをサポートします。ダウンストリームの検証コードに特別な状況は必要ありません。
-簡単にシリアル化/逆シリアル化
-無制限の数の署名者

### ネガティブ

-より大きなコードベースですが、新しいインターフェイスを提供しないため、これはtendermint/cryptoのサブフォルダーに配置する必要があります。 (参照#https://github.com/tendermint/go-crypto/issues/136)
-アミノコードを使用しているため、スペース効率が低い
-提案された実装では、ASMごとに新しい構造が必要です。

### ニュートラル
