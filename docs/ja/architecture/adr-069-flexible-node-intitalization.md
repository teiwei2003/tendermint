# ADR 069:柔軟なノードの初期化

## 長いログ

-2021-06-09:最初のドラフト(@tychoish)

-2021-07-21:メジャーリビジョン(@tychoish)

## ステータス

提案しました。

## 環境

[Go-API-Stability](./ adr-060-go-api-stability.md)をサポートするには、
0.35の開発サイクルでは、APIを削減しようとしています
`node`パッケージのインターフェースのほとんどをに移動することによって
エクスポートされていない関数、およびリアクターを「内部」に移動する
パック。バージョン0.35と一致することは理にかなっています
これらのインターフェースは `p2p`のために_have_変更されたため
[リファクタリング](./ adr-061-p2p-refactor-scope.md)なので、考えるのは理にかなっています
テンダーミントがこのAPIを公開する方法の詳細。

P2Pレイヤーとほとんどのノードパッケージのインターフェースは
一部を除外する内部化
ライブラリのユーザーとしてtendermintを使用します。具体的には、内省
最新バージョンは、テンダーミントノードサービスと交換用コンポーネントをサポートしていません
コードのバージョン、いくつかのユースケースは維持する必要があります
コードのベンダーコピー。これらの機能を追加するには、非常に広範囲にわたる必要があります
(内部/実装) `node`および` rpc`パッケージへの変更、およびこれ
ADRは、テンダーミントノードの初期化方法を変更するためのモデルを記述しています。
このような機能を提供するサービス。

現在の実装ではノードの初期化を検討します
すべてのコンポーネント間に強力な接続を提供し、
考えることができるノードおよびRPCレイヤーコンポーネント
これらのコンポーネントの相互作用は、これらを達成するのに役立ちます
機能し、ノードパッケージの要件を定義するのに役立ちます。

## 代替方法

これらの代替案を提案して、デザインスペースを構築し、
決定を製品要件に関連付けます。これらは
アイデアは本質的に悪いものではなく、可能または望ましいものでさえあります
(遠い)将来、追加の背景メモのみが提供されます
私たちはその瞬間に決断を下しました。

### 何もしなかった

現在の実装は、大部分を満たすのに十分機能的です
ほとんどのユースケース(例:Cosmos-SDKのすべてのユーザーと
テンダーミントとABCIアプリを個別に実行する人
処理する)。現在の実装では、以前のバージョンでも、
ノードの初期化を変更するか、カスタムコンポーネントを挿入する必要があります
`node`パッケージのほとんどをコピーします。これにはそのようなユーザーが必要です
テンダーミントの販売コピーを維持します。

これは(おそらく)長期的には受け入れられませんが、ユーザーが望むとおりです
よりモジュール化され、現在のサービス実装は脆弱です
維持が困難で、短期的に遅れる可能性があります
少し実行します。しかし、最終的には、
`node`パッケージは、保守と推論が簡単です。

### ユニバーサルサービスのプラグ可能性

考えられるシステム設計の1つは、インターフェースをエクスポートすることです(Golangで
センス)システムのすべてのコンポーネントに対して、実行時の依存関係を許可します
システム内のすべてのコンポーネントを挿入して、ユーザーが記述できるようにします
ユーザー提供のコンポーネントのテンダーミントノード。

このレベルのカスタマイズにはメリットがありますが、非常に大きなものになります
私たちが持っていない約束(特にAPI設計作業について)
現在のスコープ。最終的に特定のタイプのサポートを提供します
プラグ可能性は有用である可能性があるため、現在の解決策は明確ではありません
この選択の可能性を排除します。

### 抽象的な依存関係に基づく起動とシャットダウン

このドキュメントの主な提案により、テンダーミントノードの初期化が容易になります
より抽象的なですが、システムにはいくつかが欠けています
デーモン/サービスの初期化が提供できる機能、たとえば
システムにより、サービスの作成者は初期化とシャットダウンのシーケンスを制御できます
依存関係コンポーネントを使用します。

このようなシステムは、サービス宣言を許可することで機能します
他のreactorの初期化シーケンスへの依存(おそらくIDによる)
ノードがに基づくことができるように
リクエストノードではなく、サービス宣言の依存関係
このロジックを直接コーディングします。

このレベルの構成は、必要以上に複雑になる可能性があります。与えられた
テンダーミントの現在の実装におけるコンポーネントの作成者
依存関係ベースのシステムである他のコンポーネントをすでに理解する必要があります
この段階では抽象的すぎるかもしれません。

## 決定

-コードベースを可能な限り検討して、
  パッケージは、それ自体の初期化と最小化を担当します
  `node`パッケージ自体のコードの量。

-設計目標として、直接結合と依存関係を減らします
  `node`の実装におけるコンポーネント。

-より柔軟な内部フレームワークで反復を開始します
  初期化プロセスのためにテンダーミントノードを初期化します
  ノードオブジェクトの実現により、ハードコーディングを削減します。

  -リアクターは、インターフェースを「内部」で公開する必要はありません。
ノードタイプの実装

  -このリファクタリングは、ユーザーには完全に不透明である必要があります。

  -これらのノード初期化の変更は必要ありません
「service.Service」または一般的な初期化を再評価します
オーケストレーションフレームワーク。

-注射システムを積極的に提供しないでください
  コンポーネント/サービス
  このプラガビリティが将来改善される可能性がある場合
  必要。

-回避するために、p2pベースの状態同期リアクターの実装を優先します
  ユーザーは、カスタム状態同期プロバイダーを挿入する必要があります。

## 詳細設計

[現在
nodeImpl](https://github.com/tendermint/tendermint/blob/master/node/node.go#L47)
各実装への直接参照を含める
Reactorは、「service.Service」への参照に置き換える必要があります
物体。これにはモバイルビルドが必要になります[rpc
サービス](https://github.com/tendermint/tendermint/blob/master/node/node.go#L771)
コンストラクターを入力します
[makeNode](https://github.com/tendermint/tendermint/blob/master/node/node.go#L126)。 1
可能な実装は、現在のを排除することです
ノードパッケージの `ConfigureRPC`メソッドですが、[Configure it
こちら](https://github.com/tendermint/tendermint/pull/6798/files#diff-375d57e386f20eaa5f09f02bb9d28bfc48ac3dca18d0325f59492208219e5618R441)。

`node`パッケージの複雑さを増すことを避けるために、
`service`パッケージの複合サービス実装
`service.Service`を実装し、一連の
低レベルの `service.Service`オブジェクトとそれらを処理します
指定された順序でオン/オフします。

コンセンサス、ブロック同期(* nee *高速同期)、および状態同期はすべて、
相互に、そして重要な初期化の依存関係があります
現在、 `node`パッケージにエンコードされています。この変更の一環として、
新しいパッケージ/コンポーネント(「ブロック」という名前の場合があります。
`internal/blocks`)はこれらのブロックの初期化をカプセル化します
コード管理領域。

### 注射可能なコンポーネントオプション

このセクションでは、可能な実装について簡単に説明します
ノードで実行されているユーザーによって提供されるサービス。これはすべきではありません
ユーザー提供のコンポーネントが厳しい要件でない限り
1人のユーザー。

コンポーネントの交換を可能にするために、新しいパブリック関数
署名付きで `node`のパブリックインターフェースに追加されます
次のようになります。

```go
func NewWithServices(conf *config.Config,
	logger log.Logger,
	cf proxy.ClientCreator,
	gen *types.GenesisDoc,
	srvs []service.Service,
) (service.Service, error) {
```

`service.Service`オブジェクトは、指定された順序で初期化されます。その後、
すべての事前構成済み/デフォルトのサービスが開始されました(そして逆に閉じられました)
注文)。特定のサービスは追加のインターフェースを実装して、それらを許可することができます
特定のデフォルトサービスを置き換えます。 `NewWithServices`は入力を検証します
次のルールを持つサービスのリスト:

-実行中のサービスがない可能性があります。
-発信者は、特定のリアクターに複数の代替リアクターを提供することはできません
  デフォルトのサービスタイプ。

発信者がこれらのルールのいずれかに違反した場合、 `NewWithServices`は戻ります
間違い。将来的にそのような操作のサポートを撤回するために、
この関数は、*常に*エラーを返すように変更できます。

## 結果

### ポジティブ

-ノードパッケージの保守が容易になります。

-テンダーミントにサービスを追加するのが簡単になります
  ノード。

-ノードのデフォルトコンポーネントを置き換えることができます
  テンダーミントレポを販売せずにパッケージ化し、内部を変更する
  コード。

-現在のエンドツーエンド(e2e)テストスイートは、
  回帰、および新機能の徹底的な単体テストを実行できます。

-このプロジェクトの範囲は非常に狭く、リスクを最小限に抑えることができます。

### ネガティブ

-これにより、 `service.Service`インターフェースへの依存度が高まります。
  それは私たちが完全に約束したいインターフェースではないかもしれません。

-提案はかなり小さな機能セットを実装し、
  それは多くの追加機能の可能性を残します
  この提案の範囲には含まれていません。

### ニュートラル

適用できない

## 未解決の問題

-この新しい初期化フレームワークはどのくらい適応する必要がありますか
  従来のp2pスタック？大幅に遅らせることは可能ですか
  この複雑さを回避するために0.36サイクルで作業しますか？

  -回答:_時間に依存します_、およびプラグ可能な原子炉を0.35で出荷するための要件。

-追加のパブリックタイプを0.35でエクスポートする場所
  リリース？

  非推奨になっているAPI安定化共通プロジェクトに関連して
  `types`パッケージを作成し、その内容を新しい` pkg`階層に移動します。
  ただし、現在、 `pkg`インターフェースの設計については詳しく説明されていません。
  バージョン0.35で `types`を保持したい場合は、検討する必要があります
  1つのコードで複数の編成メソッドを使用することの影響
  単一の問題。

## 将来の仕事

-`service.Service`インターフェースを改善または簡素化します。幾つかある
  このインターフェースの制限は非常に明白です(
  タイムアウトモードのスロースタートまたはクローズ、間のサイクル
  `service.BaseService`と` service.Service`の実装は
  気がかりなことに、 `OnReset`のデフォルトのパニックは気がかりなようです。 )。

-`service.Service`のリファクタリングの一環として、すべてのサービス/ノードを用意します
  `context.Context`オブジェクトのライフサイクルを尊重し、回避する
  p2pで `context.Context`オブジェクトを作成する現在の慣行と
  リアクターコード。これは、インプロセスマルチテナンシーに必要です。

-コンポーネント間の明示的な依存関係をサポートし、許可する
  並列始動。これにより、異なる原子炉を同時に始動できます。
  可能であれば、時間。

## 参照する

- [この
  ブランチ](https://github.com/tendermint/tendermint/tree/tychoish/scratch-node-minimize)
  ノードパッケージを実装するための実験的な作業が含まれています
  コンポーネント間のいくつかのハードな依存関係を削除します。

-[成分
  図)(https://peter.bourgon.org/go-for-industrial-programming/#the-component-graph)
  内部サービス構築のフレームワークとして。

## 付録

### 依存

ブロックチェーンとコンセンサスリアクターの間には関係があります
次の依存関係グラフの説明は、いくつかの置き換えを行います
これらのコンポーネントはより難しいか
コンポーネント。

！[コンセンサスブロックチェーン依存関係グラフ](./img/consensus_blockchain.png)
