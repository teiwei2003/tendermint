# ADR 047:ライトクライアントからの証拠を処理する

## 変更ログ
* 18-02-2020:最初のドラフト
* 24-02-2020:第2版
* 13-04-2020:PotentialAmnesiaEvidenceといくつかのメモを追加
* 31-07-2020:PhantomValidatorEvidenceを削除
* 14-08-2020:ライトトレイルを導入(現在は代替方法としてリストされています)
* 20-08-2020:ライトクライアントは、フルノードに渡すのではなく、検出されたときに証拠を生成します
* 2020年9月16日:実装後に改訂
* 15-03-2020:フォワードマッドマン攻撃の状況を修正

### 用語

-`LightBlock`は、ライトクライアントによって受信、検証、および保存されるデータユニットです.
これは、非常に同一のバリデーター、送信、およびヘッダーのセットで構成されています.
-**トレース**は、高さ範囲の一連のライトブロックと見なされます
検証をスキップするために作成されました.
-**プロバイダー**は完全なノードであり、ライトクライアントはライトクライアントに接続してサービスを提供します
クライアントによって署名されたヘッダーとベリファイアのセット.
-`VerifySkipping`(隣接していないことの二等分または検証と呼ばれることもあります)は1つの方法です
ライトクライアントは、信頼できるヘッダーからターゲットヘッダーを検証するために使用されます.プロセスには検証が含まれます
検証者の1/3が中間ヘッダーに署名したことを確認する
信頼できるヘッダーは、信頼できないヘッダーにも署名しました.
-**ライト分岐ポイント**:ライトクライアントが2つのプロバイダーを使用して「VerifySkipping」を実行する場合
(つまり、メインと証人)、分岐点はタイトルの高さです
これらのプロバイダーはそれぞれ異なりますが、効果的です.これは、プロバイダーの1つが
軽いクライアントをだまそうとするかもしれません.

## 環境

ライトクライアントが使用するヘッダー検証の二分法が公開されています
ライトクライアントの信頼期間内のいずれかのブロックが
パワーがライトクライアントの信頼レベルを超える悪意のある検証者のグループ
(デフォルトは1/3です).ライトクライアント(およびネットワーク全体)のセキュリティを向上させるために、ライト
クライアントには、比較に使用される検出器コンポーネントがあります
主に証人ヘッダー用.このADRは、攻撃を軽減するプロセスの概要を示しています
相互参照は、監視ノードを使用してライトクライアントで実行されます.

## 代替方法

前述の証拠を処理する方法は、すべてのデータを渡すことです
ライトクライアントは、フルノードのさまざまなヘッダーを観察したときに目撃しました
処理する.これはライトトレイルと呼ばれ、次の構造になっています.

`` `行く
タイプConflictingHeadersTracestruct {
  ヘッダー[] * types.SignedHeader
}
`` `

この方法の利点は、光の処理をあまり必要としないことです.
クライアントで攻撃が発生したとき.ただし、これは重要ではありません
違いは、ライトクライアントはどのような場合でもすべてのヘッダーを検証する必要があることです
目撃者とメインから.トレースを使用すると、多くの帯域幅が消費されます
そして、DDOSベクトルをフルノードに追加します.


## 決定

ライトクライアントは、「バリデーター」(シーケンシャルまたは
スキップ)と `detector`([Informal Detector](https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/detection/detection.md)を参照)
検出器はメインサーバーからタイトルのトレースを取得し、すべてを比較します
目撃者.頭が発散している目撃者の場合、検出器は最初に頭を確認します
メインの提供されたトレースによって定義されたすべての高さを半分にすることによって.それが機能する場合、
ライトクライアントは2つのトレースをトラバースし、その分岐点を見つけます
証拠を抽出し続けることができます(後で詳しく説明します).

証拠の検出に成功した後、ライトクライアントはそれをメインに送信し、
停止する前に証言します.他のピアに証拠を送信したり、検証を継続したりすることはありません
メインヘッダーとその他のヘッダー.


## 詳細設計

ライトクライアントの検証プロセスは、信頼できる最初から始まり、二分法を使用します
指定された高さのタイトルを検証するアルゴリズム.これは検証済みのヘッダーになります(
それが信頼できることを意味します). 2つの間で検証されたすべてのヘッダーがキャッシュされ、呼び出されます
中間ヘッダーと配列全体は、トレースと呼ばれることもあります.

次に、ライトクライアントの検出器がすべてのヘッダーを取得し、検出機能を実行します.

```golang
func (c *Client) detectDivergence(primaryTrace []*types.LightBlock, now time.Time) error
```

この関数は、受信した最後のヘッダーであるターゲットヘッダーを取得し、それをすべての監視者と比較します
次の関数を渡します.

```golang
func (c *Client) compareNewHeaderWithWitness(errc chan error, h *types.SignedHeader,
	witness provider.Provider, witnessIndex int)
```

errチャネルは、すべての結果を送り返して、それらを並行して処理できるようにするために使用されます.
ヘッダーが無効な場合、監視が破棄されたり、応答が欠落したり、ヘッダーが無視されたりします
同じハッシュを持つヘッダーのように. しかし、タイトル、
次に、異なるハッシュが、メインの証人とその特定の証人の間の検出プロセスをトリガーします.

これは最初に、並行して実行される検証をスキップすることにより、証人のヘッダーを検証します
光の分岐点を見つける

![](../imgs/light-client-detector.png)

これは次の方法で行われます.
```golang
func (c *Client) examineConflictingHeaderAgainstTrace(
	trace []*types.LightBlock,
	targetBlock *types.LightBlock,
	source provider.Provider,
	now time.Time,
	) ([]*types.LightBlock, *types.LightBlock, error)
```

以下をせよ

1.信頼できるヘッダーが同じかどうかを確認します.現在、それらは理論的に異ならないはずです
クライアントの初期化後に監視を追加または削除できないためです.しかし、私たちは何らかの方法でそれを行います
健全性チェックとして.これが失敗した場合、私たちは証人をあきらめなければなりません.

2.二分法を使用して、すべてのノードの同じ高さで証人の頭を照会および検証します
メインの中間ヘッダー(上記の例ではA、B、C、D、F、H).二分法が失敗した場合
または、目撃者が応答を停止した場合、目撃者を問題と呼び、それを放棄することができます.

3.最終的に、真ん中の頭とは異なる、証人を通して確認された頭を取得しました
(上記の例では、これはEです).これが分岐点です(これが最後のタイトルになる場合もあります).

4.チェックされているトレースのブロックが大きくなるという独特の状況があります
高さがターゲットブロックよりも高くなっています.これは、主に以下を含むフォワードクレイジー攻撃の一部として発生する可能性があります
高さがチェーンヘッドよりも高いライトブロックを用意します(付録Bを参照).これで
この場合、ライトクライアントはtargetBlockまでソースブロックを検証し、
高さがtargetBlockの直後に続くトレースは、ConflictingBlockと呼ばれます.

次に、この関数は、共通ヘッドと共通ヘッドの間の監視ノードからブロックのトレースを返します.
右の例に示すように、複数の可能性が非常に高いため、主な発散ヘッド
異なるタイトルを確認するために必要なタイトル.このトレースは
後で使用します(このドキュメントの後半で説明します).

！[](../imgs/bifurcation-point.png)

攻撃が検出されたので、ライトクライアントはそれを証明するための証拠を作成する必要があります.持ってる
メインまたは目撃者は、ライトクライアントをだまそうとするために3種類の攻撃を実行する可能性があります
間違ったタイトルを確認してください:Lunatic、Equivocation、およびAmnesia.結果は同じなので
それを証明するために必要なデータも非常に似ています.これらの攻撃方法をバンドルします
証拠:

```golang
type LightClientAttackEvidence struct {
	ConflictingBlock *LightBlock
	CommonHeight     int64
}
```

ライトクライアントは、最初にメインクライアントを疑う立場になります.見つかった分岐点を考えると
上記では、2つの異なるヘッダーを取得し、メインのヘッダーが有効かどうかを比較しています
目撃者を尊重します.これは `isInvalidHeader()`を呼び出すことによって行われます.
決定論的に導出されたヘッダーフィールドのいずれかが互いに異なります.これはそれらの1つかもしれません
`ValidatorsHash`、` NextValidatorsHash`、 `ConsensusHash`、` AppHash`、および `LastResultsHash`.
この場合、目撃者が私たちが高さを送ることを確認するのを助けるために、これが狂人の攻撃であることを私たちは知っています
上記の例の1または上記の例のCの共通ヘッダー.このすべての場合
ハッシュ値が同じである場合、それはEquivocationまたはAmnesiaであると推測できます.この場合、送信します
バリデーターセットが同じであることがわかっているため、発散ヘッドの高さ.
悪意のあるノードはまだその高さにバインドされています.上記の例では、これは高さ10であり、
上記の例はEでの高さです.

ライトクライアントは証拠を所有し、それを証人にブロードキャストします.

ただし、ライトクライアントが使用するヘッダーはメインの証人からのものである可能性があります
偽造されているため、ライトクライアントを停止する前にプロセスを交換し、目撃者を疑って
メインを使用して証拠を作成します.今回は `examineConflictingHeaderAgainstTrace`を呼び出して使用します
以前に発見された目撃者の痕跡.
主に悪意のあるものである場合は応答しない可能性が高いですが、無実の場合は
軽いクライアントは同じ証拠を提供しますが、今回は矛盾しています
ブロックは、マスターノードではなくウィットネスノードから取得されます.次に、証拠を作成し、に送信します
マスターノード.

これでプロセスが終了し、最初に呼び出された検証関数がエラーを次のように返します.
ユーザー.

これら3つの攻撃のそれぞれを実行する方法の詳細な概要については、を参照してください.
[フォーク責任仕様](https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md).

##フルノード検証

フルノードがライトクライアントから証拠を受信すると、検証する必要があります
同僚とチャットしてチェーンに送信する前に、自分で考えてください.プロセスの概要
 [ADR-059](https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-059-evidence-composition-and-lifecycle.md).

## ステータス

実装

## 結果

### ポジティブ

*ライトクライアントは、Lunatic、Equivocation、Amnesiaの攻撃に対するセキュリティを向上させます.
*悪意のある動作をカプセル化するための中間データ構造は必要ありません
*一般化の証拠により、コードが単純化されます

### ネガティブ

*ライトクライアントの0.33.8以下のバージョンからの重要な変更.ついさっき
バージョンは引き続き `ConflictingHeadersEvidence`を送信しますが、認識されません
フルノードを介して.ただし、ライトクライアントはヘッダーを拒否して閉じます.
*健忘症の発作は発見されましたが、そうではないため罰せられません
現在の情報から削除されるノードは悪意があります.
*証拠モジュールは、個人の証拠とグループの証拠を同時に処理する必要があります.

### ニュートラル

## 参照する

* [フォークアカウンタビリティ仕様](https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md)
* [ADR 056:ライトクライアント記憶喪失攻撃](https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-056-light-client-amnesia-attacks.md)
* [ADR-059:証拠の構成とライフサイクル](https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-059-evidence-composition-and-lifecycle.md)
* [Informalのライトクライアント検出器](https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/detection/detection.md)


## 付録A

PhantomValidatorEvidenceは、まだ誓約されているバリデーターをキャプチャするために使用されます
(つまり、結合期間中)しかし、現在のバリデーターのセットではブロックに投票していません.

後の議論で、ファントムバリデーターは保持できるが、一部の人々は考えました
いずれにせよ、参加できる可能性のあるファントムバリデーターの証拠
軽いクライアントをだますには、1/3以上のクレイジーなバリデーターの助けを借りる必要があります.

クレイジーな攻撃によって注入された新しいバリデーターもありそうにありません
まだ何かを保持しているバリデーターになります.

それだけでなく、すべてを保存するために多くの追加の計算が必要です
現在誓約されているバリデーターは
仮想バリデーター.このため、削除されました.

## 付録B

マッドアタックのユニークなフレーバーは、フォワードマッドアタックです.これは悪意のある場所です
ノードは、高さがブロックチェーンの高さよりも大きいヘッダーを提供します.だからあります
悪意のある称号に異議を唱えることができる目撃者はいません.そのような攻撃も
共犯者が必要です.つまり、少なくとも1人の他の証人も同じ偽のタイトルを返します.
このような攻撃はどの高さでも実行できますが、それでも維持する必要があります.
ライトクライアントのリアルタイムクロックがドリフトします.したがって、この攻撃を検出するために、
お客様はしばらくお待ちください
```
2 * MAX_CLOCK_DRIFT + LAG
```

目撃者に、所有する最新のブロックを提供させます. 制限時間を考えると、証人が
ブロックチェーンのヘッドで実行すると、より高い高さのヘッドがありますが、
後でタイムスタンプ. これは、プライマリが狂気のヘッダーを送信したことを証明するために使用できます
これは、単調に増加する時間に違反します.
