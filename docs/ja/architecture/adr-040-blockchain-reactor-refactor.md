# ADR 040:ブロックチェーンリアクターの再構築

## 変更ログ

2019年3月19日:最初のドラフト

## 環境

ブロックチェーンリアクターの高レベルの責任は、ピアノードを現在の状態よりはるかに遅れさせることです.
ブロックチェーンは、ピアから多数のブロックを並行してダウンロードし、ブロックの正当性を検証することで、すぐに追いつきます.
ABCIアプリケーション用に実行します.ブロックチェーンリアクターによって実装されるプロトコルを「高速同期」と呼びます.
ブロックチェーンリアクターの現在のアーキテクチャ図は、次の場所にあります.

！[ブロックチェーンリアクタアーキテクチャ図](img/bc-reactor.png)

現在のアーキテクチャは数十のルーチンで構成されており、 `Switch`に密接に依存しており、
ユニットテストはほとんど不可能です.現在のテストでは、複雑な依存関係グラフを設定し、同時実行性を処理する必要があります.
この場合、ほとんどの時間ルーチンがアイドル待機状態にあるため、数十のルーチンを持つことは冗長であることに注意してください.
何が起こりますか(メッセージの到着またはタイムアウトが期限切れになります). `Switch`に依存しているため、テストは比較的
複雑なネットワークシナリオと障害(ピアの追加や削除など)は非常に複雑なタスクであり、多くの場合、
動作が不確実な複雑なテスト([#3400]).適切なテストを書くことができないと、人々は感じます
コードが低いため、いくつかの問題が発生しました(その間に修正されたものもあれば、まだ開いているものもあります).
[#3400]、[#2897]、[#2896]、[#2699]、[#2888]、[#2457]、[#2622]、[#2026].

## 決定

これらの問題を解決するために、ブロックチェーン原子炉の大規模な再建を行う予定です.提案されたアーキテクチャは主に触発されています
次の図に示すように、ADR-30によって提供されます.
！[ブロックチェーンリアクター再構築図](img/bc-reactor-refactor.png)

コアアルゴリズム(これを「コントローラー」と呼びます)を限定的に抽出する並行アーキテクチャーを採用することを提案します.
ステートマシン.原子炉の活動ルーチンは「エグゼキュータ」と呼ばれ、送受信を担当します
ピアとの間でメッセージを送信し、タイムアウトをトリガーします.送信するメッセージとトリガータイムアウトは主に決定されます
`コントローラー`によって.例外は、「エグゼキュータ」の責任である「ピアハートビート」メカニズムです.ハートビート
このメカニズムは、低速で応答のないピアをピアリストから削除するために使用されます.単体テストを作成する方が簡単です
このアーキテクチャは、ほとんどの主要なロジックとしての「コントローラ」機能の一部です.より単純な同時実行性を期待します
アーキテクチャは、この原子炉の性能に重大な悪影響を与えることはありません(確認済み)
実験的評価).


### 変更を実装する

「クイック同期」プロトコルのシステムモデルは次のとおりであると想定しています.

*ノードは、そのピアセットを表すすべてのノードのランダムなサブセットに接続されています.一部のノードは正しい、一部のノードは正しい
  問題がある可能性があります.障害が発生したノードの比率については想定していません.つまり、一部のノードのすべてのノードが発生する可能性があります.
ピアリングの設定に問題があります.
*正しいノード間の通信は同期的であると想定します.つまり、正しいノード `p`がメッセージ` m`を
  正しいノード「q」が時刻「t」にある場合、「q」は時刻「t + Delta」に最新ニュースを受信します.ここで、「Delta」はシステムです.
ネットワーク参加者に知られているパラメータ. `Delta`は通常、1桁より大きくなるように選択されます
正しいノード間の実際の通信遅延(最大).したがって、正しいノード `p`がリクエストメッセージを送信した場合
時間 `t`が正しいノード` q`に到達し、時間 `t + 2 * Delta`に対応する応答がない場合、` p`を想定できます.
その `q`には問題があります.コンセンサスリアクターのネットワークの仮定は異なることに注意してください(部分的に仮定します
同期モデル).

「QuickSync」プロトコルの要件は、正式には次のように規定されています.

-`Correctness`:正しいノード `p`が正しいノード` q`に十分な長さで接続されている場合、 `p`
-最終的に、要求されたすべてのブロックが `q`からダウンロードされます.
-`Termination`:正しいノード `p`のピアのセットが安定している場合(` p`のピアのセットに新しいノードは追加されません)
-十分な長さで、契約は最終的に終了します.
-`Fairness`:正しいノード `p`は、ブロックの要求をそのピアセット内のすべてのピアノードに送信します.

上記のように、「Executor」は「fast-sync」に属するメッセージの送受信を担当します.
プロトコル.次のメッセージは、「QuickSync」プロトコルの一部として交換されます.
``` go
type Message int
const (
  MessageUnknown Message = iota
  MessageStatusRequest
  MessageStatusResponse
  MessageBlockRequest
  MessageBlockResponse
)
```
`MessageStatusRequest`は、現在の高さ要求を提供するピアとして、すべてのピアに定期的に送信されます. それは
「ピアハートビート」メカニズムの一部であり、このメッセージに時間内に応答しないと、ピアが削除されます
ピアグループから. 「ピアツーピアハートビート」メカニズムは、ピアが「クイック同期」モードの場合にのみ使用されることに注意してください. 私たちは推測します
ここには、ノードが「クイック同期」モードであることをピアに通知できるようにするメカニズムがあります.

``` go
type MessageStatusRequest struct {
  SeqNum int64     // sequence number of the request
}
```
`MessageStatusResponse`は` MessageStatusRequest`への応答として送信され、現在のピアのリクエスターに通知します
高い.

``` go
type MessageStatusResponse struct {
  SeqNum int64     // sequence number of the corresponding request
  Height int64     // current peer height
}
```

`MessageBlockRequest`は、指定された高さでブロックと対応する送信証明書を要求するために使用されます.

``` go
type MessageBlockRequest struct {
  Height int64
}
```

`MessageBlockResponse`は、対応するブロック要求への応答です. ブロックを提供することに加えて
対応する提出証明書.現在のピアの高さも含まれています.

``` go
type MessageBlockResponse struct {
  Height         int64
  Block          Block
  Commit         Commit
  PeerHeight     int64
}
```

メッセージの送受信に加えて、 `HeartBeat`メカニズムがあり、コントローラーはタイムアウトも管理します
「コントローラー」から要求されたときにトリガーされます. タイムアウトが経過すると、「コントローラー」に通知されます.

``` go
type TimeoutTrigger int
const (
  TimeoutUnknown TimeoutTrigger = iota
  TimeoutResponseTrigger
  TimeoutTerminationTrigger
)
```

`Controller`は、明確に定義された入力を持つ関数としてモデル化できます.

* `State`-ノードの現在の状態. 接続されたピアとその動作、保留中のリクエスト、
*受け取ったブロックなど.
* `Event`-ネットワーク内の重要なイベント.

明確な出力を生成します.

* `State`-ノードの更新状態.
* `MessageToSend`-どのメッセージをどのピアに送信するかを示します
* `TimeoutTrigger`-タイムアウトをトリガーする必要があることを示します.


次の「イベント」タイプを検討します.

``` go
type Event int
const (
  EventUnknown Event = iota
  EventStatusReport
  EventBlockRequest
  EventBlockResponse
  EventRemovePeer
  EventTimeoutResponse
  EventTimeoutTermination
)
```

`EventStatusResponse` event is generated once `MessageStatusResponse` is received by the `Executor`.

``` go
type EventStatusReport struct {
  PeerID ID
  Height int64
}
```

`EventBlockRequest` event is generated once `MessageBlockRequest` is received by the `Executor`.

``` go
type EventBlockRequest struct {
  Height int64
  PeerID p2p.ID
}
```
`EventBlockResponse` event is generated upon reception of `MessageBlockResponse` message by the `Executor`.

``` go
type EventBlockResponse struct {
  Height             int64
  Block              Block
  Commit             Commit
  PeerID             ID
  PeerHeight         int64
}
```
`EventRemovePeer` is generated by `Executor` to signal that the connection to a peer is closed due to peer misbehavior.

``` go
type EventRemovePeer struct {
  PeerID ID
}
```
`EventTimeoutResponse` is generated by `Executor` to signal that a timeout triggered by `TimeoutResponseTrigger` has
expired.

``` go
type EventTimeoutResponse struct {
  PeerID ID
  Height int64
}
```
`EventTimeoutTermination` is generated by `Executor` to signal that a timeout triggered by `TimeoutTerminationTrigger`
has expired.

``` go
type EventTimeoutTermination struct {
  Height int64
}
```

`MessageToSend` is just a wrapper around `Message` type that contains id of the peer to which message should be sent.

``` go
type MessageToSend struct {
  PeerID  ID
  Message Message
}
```

コントローラのステートマシンは、次の2つのモードにすることができます.
ノードは、コミットされたブロックをダウンロードすることによってネットワークに追いつくことを試みています.
Tendermintコンセンサスプロトコルを実行する `ModeConsensus`. 我々
コントローラがに切り替わると、「高速同期」モードが終了することを考慮してください
`ModeConsensus`.

``` go
type Mode int
const (
  ModeUnknown Mode = iota
  ModeFastSync
  ModeConsensus
)
```
`Controller` is managing the following state:

``` go
type ControllerState struct {
  Height             int64            // the first block that is not committed
  Mode               Mode             // mode of operation
  PeerMap            map[ID]PeerStats // map of peer IDs to peer statistics
  MaxRequestPending  int64            // maximum height of the pending requests
  FailedRequests     []int64          // list of failed block requests
  PendingRequestsNum int              // total number of pending requests
  Store              []BlockInfo      // contains list of downloaded blocks
  Executor           BlockExecutor    // store, verify and executes blocks
}
```

`PeerStats` data structure keeps for every peer its current height and a list of pending requests for blocks.

``` go
type PeerStats struct {
  Height             int64
  PendingRequest     int64             // a request sent to this peer
}
```

`BlockInfo` data structure is used to store information (as part of block store) about downloaded blocks: from what peer
 a block and the corresponding commit certificate are received.
``` go
type BlockInfo struct {
  Block  Block
  Commit Commit
  PeerID ID                // a peer from which we received the corresponding Block and Commit
}
```

The `Controller` is initialized by providing an initial height (`startHeight`) from which it will start downloading
blocks from peers and the current state of the `BlockExecutor`.

``` go
func NewControllerState(startHeight int64, executor BlockExecutor) ControllerState {
  state = ControllerState {}
  state.Height = startHeight
  state.Mode = ModeFastSync
  state.MaxRequestPending = startHeight - 1
  state.PendingRequestsNum = 0
  state.Executor = executor
  initialize state.PeerMap, state.FailedRequests and state.Store to empty data structures
  return state
}
```

The core protocol logic is given with the following function:

``` go
func handleEvent(state ControllerState, event Event) (ControllerState, Message, TimeoutTrigger, Error) {
  msg = nil
  timeout = nil
  error = nil

  switch state.Mode {
  case ModeConsensus:
    switch event := event.(type) {
    case EventBlockRequest:
      msg = createBlockResponseMessage(state, event)
      return state, msg, timeout, error
    default:
      error = "Only respond to BlockRequests while in ModeConsensus!"
      return state, msg, timeout, error
    }

  case ModeFastSync:
    switch event := event.(type) {
    case EventBlockRequest:
      msg = createBlockResponseMessage(state, event)
      return state, msg, timeout, error

    case EventStatusResponse:
      return handleEventStatusResponse(event, state)

    case EventRemovePeer:
      return handleEventRemovePeer(event, state)

    case EventBlockResponse:
      return handleEventBlockResponse(event, state)

    case EventResponseTimeout:
      return handleEventResponseTimeout(event, state)

    case EventTerminationTimeout:
      // Termination timeout is triggered in case of empty peer set and in case there are no pending requests.
      // If this timeout expires and in the meantime no new peers are added or new pending requests are made
      // then `fast-sync` mode terminates by switching to `ModeConsensus`.
      // Note that termination timeout should be higher than the response timeout.
      if state.Height == event.Height && state.PendingRequestsNum == 0 { state.State = ConsensusMode }
      return state, msg, timeout, error

    default:
      error = "Received unknown event type!"
      return state, msg, timeout, error
    }
  }
}
```

``` go
func createBlockResponseMessage(state ControllerState, event BlockRequest) MessageToSend {
  msgToSend = nil
  if _, ok := state.PeerMap[event.PeerID]; !ok { peerStats = PeerStats{-1, -1} }
  if state.Executor.ContainsBlockWithHeight(event.Height) && event.Height > peerStats.Height {
    peerStats = event.Height
    msg = BlockResponseMessage{
     Height:        event.Height,
     Block:         state.Executor.getBlock(eventHeight),
     Commit:        state.Executor.getCommit(eventHeight),
     PeerID:        event.PeerID,
     CurrentHeight: state.Height - 1,
    }
    msgToSend = MessageToSend { event.PeerID, msg }
  }
  state.PeerMap[event.PeerID] = peerStats
  return msgToSend
}
```

``` go
func handleEventStatusResponse(event EventStatusResponse, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error) {
  if _, ok := state.PeerMap[event.PeerID]; !ok {
    peerStats = PeerStats{ -1, -1 }
  } else {
    peerStats = state.PeerMap[event.PeerID]
  }

  if event.Height > peerStats.Height { peerStats.Height = event.Height }
  // if there are no pending requests for this peer, try to send him a request for block
  if peerStats.PendingRequest == -1 {
    msg = createBlockRequestMessages(state, event.PeerID, peerStats.Height)
    // msg is nil if no request for block can be made to a peer at this point in time
    if msg != nil {
      peerStats.PendingRequests = msg.Height
      state.PendingRequestsNum++
      // when a request for a block is sent to a peer, a response timeout is triggered. If no corresponding block is sent by the peer
      // during response timeout period, then the peer is considered faulty and is removed from the peer set.
      timeout = ResponseTimeoutTrigger{ msg.PeerID, msg.Height, PeerTimeout }
    } else if state.PendingRequestsNum == 0 {
      // if there are no pending requests and no new request can be placed to the peer, termination timeout is triggered.
      // If termination timeout expires and we are still at the same height and there are no pending requests, the "fast-sync"
      // mode is finished and we switch to `ModeConsensus`.
      timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }
    }
  }
  state.PeerMap[event.PeerID] = peerStats
  return state, msg, timeout, error
}
```

``` go
func handleEventRemovePeer(event EventRemovePeer, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error) {
  if _, ok := state.PeerMap[event.PeerID]; ok {
    pendingRequest = state.PeerMap[event.PeerID].PendingRequest
    // if a peer is removed from the peer set, its pending request is declared failed and added to the `FailedRequests` list
    // so it can be retried.
    if pendingRequest != -1 {
      add(state.FailedRequests, pendingRequest)
    }
    state.PendingRequestsNum--
    delete(state.PeerMap, event.PeerID)
    // if the peer set is empty after removal of this peer then termination timeout is triggered.
    if state.PeerMap.isEmpty() {
      timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }
    }
  } else { error = "Removing unknown peer!" }
  return state, msg, timeout, error
```

``` go
func handleEventBlockResponse(event EventBlockResponse, state ControllerState) (ControllerState, MessageToSend, TimeoutTrigger, Error)
  if state.PeerMap[event.PeerID] {
    peerStats = state.PeerMap[event.PeerID]
    // when expected block arrives from a peer, it is added to the store so it can be verified and if correct executed after.
    if peerStats.PendingRequest == event.Height {
      peerStats.PendingRequest = -1
      state.PendingRequestsNum--
      if event.PeerHeight > peerStats.Height { peerStats.Height = event.PeerHeight }
      state.Store[event.Height] = BlockInfo{ event.Block, event.Commit, event.PeerID }
      // blocks are verified sequentially so adding a block to the store does not mean that it will be immediately verified
      // as some of the previous blocks might be missing.
      state = verifyBlocks(state) // it can lead to event.PeerID being removed from peer list
      if _, ok := state.PeerMap[event.PeerID]; ok {
        // we try to identify new request for a block that can be asked to the peer
        msg = createBlockRequestMessage(state, event.PeerID, peerStats.Height)
        if msg != nil {
          peerStats.PendingRequests = msg.Height
          state.PendingRequestsNum++
          // if request for block is made, response timeout is triggered
          timeout = ResponseTimeoutTrigger{ msg.PeerID, msg.Height, PeerTimeout }
        } else if state.PeerMap.isEmpty() || state.PendingRequestsNum == 0 {
          // if the peer map is empty (the peer can be removed as block verification failed) or there are no pending requests
          // termination timeout is triggered.
           timeout = TerminationTimeoutTrigger{ state.Height, TerminationTimeout }
        }
      }
    } else { error = "Received Block from wrong peer!" }
  } else { error = "Received Block from unknown peer!" }

  state.PeerMap[event.PeerID] = peerStats
  return state, msg, timeout, error
}
```

``` go
func handleEventResponseTimeout(event, state) {
  if _, ok := state.PeerMap[event.PeerID]; ok {
    peerStats = state.PeerMap[event.PeerID]
    // if a response timeout expires and the peer hasn't delivered the block, the peer is removed from the peer list and
    // the request is added to the `FailedRequests` so the block can be downloaded from other peer
  if peerStats.PendingRequest == event.Height {
    add(state.FailedRequests, pendingRequest)
    delete(state.PeerMap, event.PeerID)
    state.PendingRequestsNum--
    // if peer set is empty, then termination timeout is triggered
    if state.PeerMap.isEmpty() {
      timeout = TimeoutTrigger{ state.Height, TerminationTimeout }
    }
  }
  }
  return state, msg, timeout, error
}
```

``` go
func createBlockRequestMessage(state ControllerState, peerID ID, peerHeight int64) MessageToSend {
  msg = nil
  blockHeight = -1
  r = find request in state.FailedRequests such that r <= peerHeight // returns `nil` if there are no such request
  // if there is a height in failed requests that can be downloaded from the peer send request to it
  if r != nil {
    blockNumber = r
    delete(state.FailedRequests, r)
  } else if state.MaxRequestPending < peerHeight {
  // if height of the maximum pending request is smaller than peer height, then ask peer for next block
    state.MaxRequestPending++
    blockHeight = state.MaxRequestPending // increment state.MaxRequestPending and then return the new value
  }

  if blockHeight > -1 { msg = MessageToSend { peerID, MessageBlockRequest { blockHeight } }
  return msg
}
```

``` go
func verifyBlocks(state State) State {
  done = false
  for !done {
    block = state.Store[height]
    if block != nil {
      verified = verify block.Block using block.Commit // return `true` is verification succeed, 'false` otherwise

      if verified {
        block.Execute()   // executing block is costly operation so it might make sense executing asynchronously
        state.Height++
      } else {
        // if block verification failed, then it is added to `FailedRequests` and the peer is removed from the peer set
        add(state.FailedRequests, height)
        state.Store[height] = nil
        if _, ok := state.PeerMap[block.PeerID]; ok {
          pendingRequest = state.PeerMap[block.PeerID].PendingRequest
          // if there is a pending request sent to the peer that is just to be removed from the peer set, add it to `FailedRequests`
          if pendingRequest != -1 {
            add(state.FailedRequests, pendingRequest)
            state.PendingRequestsNum--
          }
          delete(state.PeerMap, event.PeerID)
        }
        done = true
      }
    } else { done = true }
  }
  return state
}
```

提案されたアーキテクチャでは、「コントローラ」はアクティブなタスクではありません.つまり、「エグゼキュータ」によって呼び出されます. によると
`Controller`と` Executor`によって返される戻り値は、ピアにメッセージを送信し( `msg`！= nil)、トリガーします.
タイムアウト( `timeout`！= nil)またはエラーの処理(` error`！= nil).
タイムアウトがトリガーされると、対応するタイムアウトイベントとともに `Controller`への入力として提供されます
タイムアウトが期限切れになりました.


## ステータス

下書き.

## 結果

### ポジティブ

-アルゴリズムの分離された実装
-改善されたテスト容易性-正当性を証明するのがより簡単
-関心の分離の明確化-推論の容易化

### ネガティブ

### ニュートラル
