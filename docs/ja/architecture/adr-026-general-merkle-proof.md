# ADR 026:一般的なメルケル認証

## 環境

「abci.ResponseQuery」のメルケル証明として、元の「[] byte」を使用します. これにより、多層メルケル証明や一般的な状況に対処することが困難になります. ここでは、新しいインターフェース「ProofOperator」が定義されています. ユーザーは、独自のMerkleプルーフ形式を定義し、それらを簡単に階層化できます.

目標:
-デコード/再コーディングなしのレイヤーマークルプルーフ
-チェーンプルーフの一般的な方法を提供します
-認証フォーマットを拡張可能にし、サードパーティの認証タイプを許可します

## 決定

### ProofOperator

`type ProofOperator`は、Merkle証明のインターフェースです. 定義は次のとおりです.

```go
type ProofOperator interface {
    Run([][]byte) ([][]byte, error)
    GetKey() []byte
    ProofOp() ProofOp
}
```

さまざまなデータ型を処理できることが証明されているため、「Run()」は「[] byte」ではなく「[] [] byte」をパラメータとして取ります.たとえば、範囲証明の「Run()」は、パラメーターとして複数のキー値を取ることができます.その後、ツリーのルートに戻ってさらに処理し、入力値を計算に使用します.

`ProofOperator`は、マークルプルーフである必要はありません.`[] byte`に長さを追加するなど、中間プロセスのパラメーターを変換できる関数にすることができます.

### ProofOp

`type ProofOp`はprotobufメッセージであり、` Type string`、 `Key [] byte`、および` Data [] byte`のトリプルです. `ProofOperator`と` ProofOp`は、 `ProofOperator.ProofOp()`と `OpDecoder()`を使用して相互に変換可能です.ここで、 `OpDecoder`は関数であり、各プルーフタイプは独自のエンコードスキームに登録できます.たとえば、JSONデコードをサポートするために、シリアル化プルーフの前にエンコードスキームのバイトを追加できます.

## ステータス

実装

## 結果

### ポジティブ

-階層化が容易になります(すべてのステップでエンコード/デコードが不要)
-サードパーティの認証形式が利用可能です

### ネガティブ

-abci.ResponseQueryのサイズが大きい
-直感的でない証明リンク( `Run()`が何をしているのか不明)
-`OpDecoder`を登録するための追加コード
