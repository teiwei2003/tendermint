# ADR 053:状態同期のプロトタイプ

ステータスの同期が[マージ]されました(https://github.com/tendermint/tendermint/pull/4705)。最新のABCIドキュメント[利用可能](https://github.com/tendermint/spec/pull/90)。詳細については、このADRの代わりに参照してください。

このADRは、初期状態の同期プロトタイプの計画の概要を示しており、フィードバックと経験を積むにつれて変更される可能性があります。これは、[ADR-042](./ adr-042-state-sync.md)での議論と発見に基づいています。背景情報については、これを参照してください。

## 変更ログ

* 2020-01-28:最初のドラフト(Eric Greenac)

* 2020-02-18:初期プロトタイプ後の更新(Erik Grinaker)
    * ABCI:欠落している「理由」フィールドを追加しました。
    * ABCI:32ビットの1ベースのブロックインデックス(0に基づく64ビット)を使用します。
    * ABCI: `RequestApplySnapshotChunk.chain_hash`を` RequestOfferSnapshot.app_hash`に移動します。
    * Gaia:スナップショットには、内部ノードとリーフノードを含むノードバージョンも含まれている必要があります。
    *実験的なプロトタイプ情報を追加しました。
    *未解決の質問と実装計画を追加しました。

* 2020-03-29:拡張および簡素化されたABCIインターフェース(Erik Grinaker)
    * ABCI: `Snapshot`の` chunks`を `chunk_hashes`に置き換えました。
    * ABCI: `SnapshotChunk`メッセージを削除しました。
    * ABCI: `GetSnapshotChunk`の名前を` LoadSnapshotChunk`に変更しました。
    * ABCI:ブロックが単に「バイト」に交換されるようになりました。
    * ABCI:チャンクは0インデックスになり、 `chunk_hashes`配列でのパリティチェックに使用されます。
    *最大ブロックサイズを16MBに減らし、スナップショットメッセージサイズを4MBに増やします。

* 2020-04-29:ABCIインターフェースの最終リリースを更新(Erik Grinaker)

## 環境

状態の同期により、新しいノードは、ブロックをダウンロードしたり、コンセンサスを渡したりすることなく、アプリケーションの状態のスナップショットを受信できます。これにより、ノードの起動速度は、すべての履歴ブロックを再生する現在の高速同期システムよりも大幅に高速になります。

[ADR-042](./ adr-042-state-sync.md)詳細な背景説明と理由。推奨事項は次のように要約できます。

*アプリケーションは定期的に完全なステータススナップショット(つまり、熱心なスナップショット)を取得します。

*アプリケーションはスナップショットを小さなブロックに分割します。これは、チェーンアプリケーションハッシュに基づいて個別に検証できます。

* Tendermintは、ライトクライアントを使用して、検証用の信頼できるチェーンアプリケーションハッシュを取得します。

* Tendermintは、複数のピアから並行してスナップショットブロックを検出してダウンロードし、チェーンアプリケーションハッシュに基づくアプリケーションと検証のために、ABCIを介してアプリケーションに渡します。

*履歴ブロックは埋め戻されないため、状態が同期されているノードには切り捨てられたブロック履歴があります。

## テンダーミントの提案

これは、Tendermintから見たスナップショット/復元プロセスについて説明しています。インターフェースは、アプリケーションに最大限の柔軟性を提供するために、可能な限り小さく、普遍的です。

### スナップショットデータ構造

ノードは、さまざまな高さで複数のスナップショットを取得できます。スナップショットは、さまざまなアプリケーション固有の形式にすることができます(たとえば、形式「1」のMessagePackと形式「2」のProtobuf、または同様のモードバージョン管理)。各スナップショットは、実際の状態データを含む複数のブロックで構成されています。これらのブロックは、並列ダウンロードに使用され、メモリ使用量を削減します。

```proto
message Snapshot {
  uint64 height   = 1;  // The height at which the snapshot was taken
  uint32 format   = 2;  // The application-specific snapshot format
  uint32 chunks   = 3;  // Number of chunks in the snapshot
  bytes  hash     = 4;  // Arbitrary snapshot hash - should be equal only for identical snapshots
  bytes  metadata = 5;  // Arbitrary application metadata
}
```

ブロックは「バイト」としてのみ交換され、16MBを超えることはできません。 `Snapshot`メッセージは4MB未満である必要があります。

### ABCI Interface

```proto
// Lists available snapshots
message RequestListSnapshots {}

message ResponseListSnapshots {
  repeated Snapshot snapshots = 1;
}

// Offers a snapshot to the application
message RequestOfferSnapshot {
  Snapshot snapshot = 1;  // snapshot offered by peers
  bytes    app_hash = 2;  // light client-verified app hash for snapshot height
 }

message ResponseOfferSnapshot {
  Result result = 1;

  enum Result {
    accept        = 0;  // Snapshot accepted, apply chunks
    abort         = 1;  // Abort all snapshot restoration
    reject        = 2;  // Reject this specific snapshot, and try a different one
    reject_format = 3;  // Reject all snapshots of this format, and try a different one
    reject_sender = 4;  // Reject all snapshots from the sender(s), and try a different one
  }
}

// Loads a snapshot chunk
message RequestLoadSnapshotChunk {
  uint64 height = 1;
  uint32 format = 2;
  uint32 chunk  = 3; // Zero-indexed
}

message ResponseLoadSnapshotChunk {
  bytes chunk = 1;
}

// Applies a snapshot chunk
message RequestApplySnapshotChunk {
  uint32 index  = 1;
  bytes  chunk  = 2;
  string sender = 3;
 }

message ResponseApplySnapshotChunk {
  Result          result         = 1;
  repeated uint32 refetch_chunks = 2;  // Chunks to refetch and reapply (regardless of result)
  repeated string reject_senders = 3;  // Chunk senders to reject and ban (regardless of result)

  enum Result {
    accept          = 0;  // Chunk successfully accepted
    abort           = 1;  // Abort all snapshot restoration
    retry           = 2;  // Retry chunk, combine with refetch and reject as appropriate
    retry_snapshot  = 3;  // Retry snapshot, combine with refetch and reject as appropriate
    reject_snapshot = 4;  // Reject this snapshot, try a different one but keep sender rejections
  }
}
```

### スナップショットを撮る

Tendermintはスナップショットプロセスをまったく知りません。これは完全にアプリケーションの問題です。次の保証を提供する必要があります。

* **定期的:**より高速なリカバリ、より低い負荷、およびより低いDoSリスクを実現するには、スナップショットをオンデマンドではなく定期的に取得する必要があります。

* **決定論的:**スナップショットは決定論的であり、すべてのノードで同じである必要があります。通常は、特定の高さ間隔でスナップショットを取得します。

* **一貫性:**スナップショットは一貫性がある必要があります。つまり、同時書き込みの影響を受けない必要があります。通常、バージョン管理やスナップショット分離をサポートするデータストレージが使用されます。

* **非同期:**スナップショットは非同期である必要があります。つまり、ブロック処理と状態遷移は停止されません。

* **チャンク:**スナップショットは適切なサイズのブロック(メガバイト単位)に分割する必要があり、各ブロックはチェーンアプリケーションハッシュに基づいて検証可能である必要があります。

* **ガベージコレクション:**スナップショットは定期的にガベージコレクションする必要があります。

### スナップショットを復元する

ノードには、状態の同期や高速同期を有効にし、ライトクライアントに信頼できるヘッダーハッシュを提供するオプションが必要です。

状態の同期と高速同期を有効にして空のノードを起動すると、スナップショットは次のように復元されます。

1.ノードは、ノードが空であるかどうか、つまり、状態もブロックもないかどうかをチェックします。

2.ノードは指定されたシードに接続してピアを見つけます。

3.ノードは完全なノードのグループに接続し、指定されたハッシュを使用して、ライトクライアントを介して信頼できるブロックヘッダーを検証します。

4.ノードは、「RequestListSnapshots」を介してP2Pを介してピアから利用可能なスナップショットを要求します。ピアは、スナップショットごとに1つのメッセージとともに、最新の10個のスナップショットを返します。

5.ノードは、複数のピアからのスナップショットを、高さと形式(逆)でソートして集約します。異なるスナップショット間に不一致がある場合は、ほとんどのピアによってホストされているスナップショットが選択されます。ノードは、次のすべての条件を満たすスナップショットが見つかるまで、高さと形式に従ってすべてのスナップショットを逆の順序でトラバースします。

    *スナップショットの高さを持つブロックは、ライトクライアントによって信頼できると見なされます(つまり、スナップショットの高さは信頼できるヘッダーよりも大きく、最新の信頼できるブロックのバインド解除期間内にあります)。

    *スナップショットの高さまたは形式は、以前の `RequestOfferSnapshot`によって明示的に拒否されませんでした。

    *アプリケーションは `RequestOfferSnapshot`の呼び出しを受け入れます。

6.ノードは、 `RequestLoadSnapshotChunk`を介して複数のピアからチャンクを並行してダウンロードします。ブロックメッセージは16MBを超えることはできません。

7.ノードは、「RequestApplySnapshotChunk」を介してデータブロックをアプリケーションに順番に渡します。

8.すべてのブロックが適用されると、ノードはアプリケーションハッシュをチェーンアプリケーションハッシュと比較します。それらが一致しない場合、エラーが発生するか、状態を破棄して再開します。

9.ノードは高速同期に切り替わり、スナップショットが復元されたときにコミットされたブロックに追いつきます。

10.ノードは通常のコンセンサスモードに切り替わります。

## ガイア提案

これは、フォーマットバージョン「1」を使用して、Gaiaから見たスナップショットプロセスについて説明しています。シリアル化形式は指定されていませんが、圧縮されたAminoまたはProtobufである可能性があります。

### スナップショットメタデータ

初期バージョンにはスナップショットメタデータがないため、空のバイトバッファに設定されます。

すべてのブロックが正常に構築されたら、スナップショットメタデータをデータベースに保存し、「RequestListSnapshots」を介して提供する必要があります。

### スナップショットブロック形式

Gaiaデータ構造は、名前付きIAVLツリーのセットで構成されています。ルートハッシュは、各IAVLツリーのルートハッシュを取得することによって構築され、次に、ソートされた名前/ハッシュマッピングのマークルツリーを構築します。

IAVLツリーはバージョン管理されていますが、スナップショットには、スナップショットとの関連性が高いバージョンのみが含まれています。すべての履歴バージョンは無視されます。

IAVLツリーは挿入順序に依存するため、同じツリーブランチ構造を生成するには、キーと値のペアを適切な挿入順序で設定する必要があります。この挿入順序は、すべてのノード(内部ノードを含む)で幅優先スキャンを実行し、一意のキーを順番に収集することで見つけることができます。ただし、ノードのハッシュ値はノードのバージョンにも依存するため、スナップショットには内部ノードのバージョン番号も含まれている必要があります。

初期プロトタイプの場合、各ブロックには、IAVLツリー全体のすべてのノードのすべてのノードデータの完全なダンプが含まれています。したがって、ブロックの数はGaiaの永続ストレージの数と同じです。ブロックの増分検証は実行されず、最終的なアプリケーションハッシュ比較はスナップショットリカバリの最後にのみ実行されます。

本番バージョンの場合、すべてのノード(リーフノードと内部ノード)のキー/値/バージョンを挿入順に格納し、適切な方法でパーティション化するだけで十分です。各ブロックの検証が必要な場合、ブロックには、たとえば完全なサブツリーのキー/値/バージョンデータとのメルケルを格納することによって、複数のストレージのルートに至るまで、メルケル証明を再構築するのに十分な情報も含まれている必要があります他のすべてのブランチマルチストアルートまでのハッシュ値。正確な方法は、サイズ、時間、および検証の間のトレードオフによって異なります。 IAVL RangeProofsの使用は、上記のデータから導出できる中間ノードやリーフノードのプルーフなどの冗長データが含まれているため、お勧めしません。

特定のサイズ制限(たとえば、10 MB)を超えないノードデータを収集してシリアル化することにより、貪欲にブロックを構築する必要があります。チャンクデータは `snapshots/<height>/<format>/<chunk>`としてファイルシステムに保存され、SHA-256チェックサムはスナップショットメタデータと一緒に保存されます。

###スナップショットのスケジューリング

スナップショットは、1000ブロックごとなど、構成可能な高さの間隔で取得する必要があります。理想的には、すべてのノードが特定のスナップショットにブロックを提供できるように、すべてのノードが同じスナップショットスケジュールを持つ必要があります。

IAVLツリーのバージョン管理により、IAVLツリーの一貫性のあるスナップショットを大幅に簡素化できます。スナップショットを作成するにはスナップショットの高さに対応するバージョンのみが必要であり、新しいバージョンを作成するには同時書き込みが必要です。 IAVLプルーニングは、スナップショットされているバージョンをプルーニングしてはなりません。

スナップショットは、たとえば最新の `n`スナップショットを保持するなど、構成可能な時間の後にガベージコレクションする必要もあります。

## 解決済みの問題

*状態同期ノードに履歴ブロックまたは履歴IAVLバージョンがない可能性はありますか？

    >はい、予想通りです。後でブロックを埋め戻すかもしれません。

*最初のバージョンではインクリメンタルブロック検証が必要ですか？

    >いいえ、簡単に始めます。ブロック検証は、Tendermintに大きな変更を加えることなく、新しいスナップショット形式で追加できます。敵対的な状況では、ノードをホワイトリストに登録してそこからブロックをダウンロードするためのサポートを検討できます。

*スナップショットABCIインターフェイスは個別のオプションのABCIサービスである必要がありますか、それとも必須ですか？

    >必須です。今のところシンプルにしてください。したがって、これは画期的な変更であり、リリースを促進します。 Cosmos SDKを使用するアプリケーションの場合、スナップショットやエラーを適用しようとしたときに提供されないデフォルトの実装を提供できます。

* `ListSnapshots`データが有効であることをどのように確認しますか？攻撃者は、偽/無効なスナップショットをDoSピアに提供できます。

    >現在、多数のピアで利用可能なスナップショットを選択するだけです。たぶんホワイトリストをサポートします。たとえば、後でスナップショットリストをブロックチェーンに配置することを検討できます。

*無効なスナップショットを提供するノードを罰する必要がありますか？どうやって？

    >いいえ、これらは完全なノードであり、バリデーターではないため、罰することはできません。それらを切断して無視してください。

*これらのスナップショットを呼び出す必要がありますか？ SDKは `PruningOptions.SnapshotEvery`に「スナップショット」という用語を使用しており、状態の同期により、スナップショットのスケジューリングとプルーニングに追加のSDKオプションが導入されます。これらのオプションは、IAVLスナップショットやプルーニングとは関係ありません。

    >はい。これらの概念が十分に明確であることを願って、あまり混乱を引き起こすことなく、状態同期スナップショットとIAVLスナップショットを参照できます。

*スナップショットとブロックメタデータをデータベースに保存する必要がありますか？データベースをブロックに使用できますか？

    >最初の方法として、メタデータをデータベースに保存し、ブロックをファイルシステムに保存します。

*高さHのスナップショットは、Hのブロックが処理される前または後に取得する必要がありますか？例えば。 RPC `/ commit`は、現在の高さの_before_である_previous_heightの後にapp_hashを返します。

    >提出後。

*ブロックチェーンリアクターのすべてのバージョンをサポートする必要がありますか(つまり、高速同期)？

    > v2が安定したら、v1リアクターを完全に削除する必要があります。

* `ListSnapshots`はリクエスト/レスポンスAPIではなくストリーミングAPIである必要がありますか？

    >いいえ、最大メッセージサイズを使用してください。

## ステータス

実装

## 参照する

* [ADR-042](./ adr-042-state-sync.md)とその参照
