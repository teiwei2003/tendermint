# ADR 016:プロトコルバージョン

## やること

-認証された暗号ハンドシェイク自体をどのように/バージョン管理する必要がありますか(つまり、
  (P2PVersionの事前合意交渉)
-ABCI自体をどのように/バージョン管理する必要がありますか？それが吸収されるべきか
  ブロックバージョン？

## 変更ログ

-2018年9月18日:実装に関する作業を行った後の更新
    -ABCIハンドシェイクは、アプリケーションの起動とは関係なく発生する必要があります
      結果を確認できるようにconns
    -ABCIプロトコルバージョンに関する質問を追加しました
-16-08-2018:SDKチームとの話し合いの後に更新
    -ヘッダー/ ABCIから信号の次のバージョンを削除します
-03-08-2018:Jaeと話し合った更新:
  -ProtocolVersionには、Current/NextではなくBlock/AppVersionが含まれています
  -EndBlockフィールドを使用して、信号をTendermintにアップグレードします
  -古いノードの同期を簡素化するために、バージョンごとにピアの互換性を制限しないでください
-28-07-2018:レビューの更新
  -2つのADRに分割-1つはプロトコル用、もう1つはチェーン用
  -タイトルにアップグレードシグナルを含める
-16-07-2018:初期ドラフト-最初はプロトコルとチェーンの共同ADR
  バージョン

## 環境

ここでは、ソフトウェアとは関係のないプロトコルバージョンに焦点を当てます。

ソフトウェアバージョンはSemVerでカバーされており、他の場所で説明されています。
プロトコルの説明とは何の関係もありません。プロトコルのバージョンがあるかどうかだけを言ってください。
変更すると、ソフトウェアバージョンが変更されますが、必ずしもその逆ではありません。

利便性/診断のために、ソフトウェアバージョンをNodeInfoに含める必要があります。

また、さまざまなブロックチェーン間のバージョン管理にも関心があります
係争中の支店を区別するなどの意味のある方法
ハードフォーク。後でADRに任せます。

## 必須

個別にアップグレードできるブロックチェーンコンポーネントのバージョン管理を実行する必要があります。
私たちはスケーラブルで保守可能な方法でそれを行う必要があります-私たちはただゴミを捨てることはできません
条件付きコード。

契約のフルバージョンには、次のサブバージョンが含まれていると見なすことができます。
BlockVersion、P2PVersion、AppVersion。これらのバージョンは、主要なサブコンポーネントを反映しています
さまざまな速度でさまざまな方法で一緒に開発される可能性のあるソフトウェア、
以下に説明するように。

BlockVersionはコアと
頻繁に変更しないでください。

P2PVersionは、ピアが相互に接続および通信する方法を定義します。
これはブロックチェーンデータ構造の一部ではありませんが、ブロックチェーンの構築に使用されるプロトコルを定義します
ブロックチェーン。徐々に変化する場合があります。

AppVersionは、次のようなアプリケーション固有の情報を計算する方法を決定します。
AppHashと結果。

これらのバージョンはすべて、ブロックチェーンのライフサイクル全体で変更される可能性があります。
新しいノードがバージョン間で変更を同期するのに役立ちます。これは、私たちが進んでしなければならないことを意味します
古いバージョンのピアに接続します。

### ブロックバージョン

-すべてのテンダーミントハッシュデータ構造(タイトル、投票、トランザクション、応答など)。
  -トランザクションのセマンティクスはAppVersionに応じて変わる可能性がありますが、txsがヘッダーにメルク化される方法はBlockVersionの一部であることに注意してください
-変更の頻度が最も少ない/変更される可能性が最も低い必要があります。
  -テンダーミントは安定している必要があります-これは単なるアトミックブロードキャストです。
  -1年以内にTendermintv2.0の使用を検討し始めることができます
-シリアル化された形式からブロックのバージョンを簡単に判別できます

### P2Pバージョン

-すべてのp2pおよびreactorメッセージング(メッセージ、検出可能な動作)
-パフォーマンスを改善し、新しい機能をサポートするために、reactorの開発に伴って徐々に変更されます-メモリプールで提案された新しいメッセージタイプBatchTxやコンセンサスのHasBlockPartなど
-最初のシリアル化されたメッセージからピアのバージョンを簡単に判別できます
-徐々にアップグレードするには、新しいバージョンが少なくとも1つの古いバージョンと互換性がある必要があります

### アプリケーションバージョン

-ABCIステートマシン(トランザクション、ブロックの開始/終了の動作、ハッシュのコミット)
-動作とメッセージの種類は、チェーンのライフサイクル中に突然変化します
-さまざまな高さのさまざまなAppVersionをサポートするために、コードの複雑さを最小限に抑える必要があります
-理想的には、ソフトウェアの各バージョンは、一度に1つの_single_AppVersionのみをサポートします
  -これは、コードを散らかす代わりに、さまざまなバージョンのソフトウェアをさまざまな高さでチェックすることを意味します
    条件付き
  -AppVersion間で必要なデータ移行の数を最小限に抑えます(つまり、ほとんどのAppVersionは、ディスクから以前のAppVersionと同じ状態を読み取ることができるはずです)。

## 理想

ソフトウェアの各コンポーネントは、モジュール方式で個別にバージョン管理されており、簡単に組み合わせてアップグレードできます。

## 提案

BlockVersion、AppVersion、P2PVersion、それぞれが単調に増加するuint64。

これらのバージョンを使用するには、ブロックヘッダー、p2p NodeInfo、およびABCIを更新する必要があります。

### タイトル

ブロックヘッダーには、最初のフィールドとして `Version`構造が含まれている必要があります。次に例を示します。

```
type Version struct {
    Block uint64
    App uint64
}
```

ここで、 `Version.Block`は現在のブロックのルールを定義し、
`Version.App`は、最後のブロックを処理して計算するアプリケーションのバージョンを定義します
現在のブロックの「AppHash」。 一緒にそれらは完全な説明を提供します
コンセンサスキー合意。

proto3ヘッダーを決定したので、シリアル化されたヘッダーからBlockVersionを読み取る機能は一貫しています。

バージョン構造を使用すると、フィールドを壊すことなく、より柔軟に追加できます。
タイトル。

ProtocolVersion構造には、ブロックバージョンとアプリバージョンが含まれています。
コンセンサスキー合意の完全な説明として。

### ノード情報

NodeInfoには、最初のフィールドとしてバージョン構造が含まれている必要があります。次に例を示します。

```
type Version struct {
    P2P uint64
    Block uint64
    App uint64

    Other []string
}
```

これにより、実質的に `Version.P2P`がNodeInfoの最初のフィールドになるため、
簡単にアップグレードする必要がある場合は、シリアル化されたヘッダーから簡単に読み取ることができます。

ここでの「Version.Other」には、ソフトウェアクライアントの名前や
これはSemVerバージョンです-これは便宜上のものです。例えば。
`tendermint-core/v0.22.8`。これは `[] string`なので、関連するものを含めることができます
Tendermintバージョン、アプリケーションバージョン、Tendermintライブラリバージョンなど。

### ABCI

ABCIはTendermintとアプリケーションの同期を維持する責任があるため、
バージョン情報を伝えるために使用する必要があります。

起動時に、Infoを使用して基本的なハンドシェイクを実行します。すべてを含める必要があります
バージョン情報。

また、ブロックチェーンのライフサイクル中にバージョンを更新できる必要があります。この
これを行う自然な場所はEndBlockです。

現在のハンドシェイクの結果はどこにも開示されていないことに注意してください。
ハンドシェイクは、 `proxy.AppConns`抽象化内で行われます。必要になります
独立して呼び出すことができるように、 `proxy`パッケージからハンドシェイクを削除します
そして、アプリケーションのバージョンを含む結果を取得します。

#### 情報

RequestInfoは、プロトコルバージョンのサポートを追加する必要があります。次に例を示します。

```
message RequestInfo {
  string version
  uint64 block_version
  uint64 p2p_version
}
```

同様に、ResponseInfoはバージョンを返す必要があります。

```
message ResponseInfo {
  string data

  string version
  uint64 app_version

  int64 last_block_height
  bytes last_block_app_hash
}
```

既存の `version`フィールドは` software_version`と呼ばれるべきですが、そのままにしておきます
破壊的な変更の数を減らすことができるようになりました。

####エンドブロック

新しいフィールドを使用するか、
既存の「ラベル」。 情報を伝えようとしているので
Tendermintブロックヘッダーに含まれているため、ABCIにネイティブである必要があります。
ラベルの特定のスキームを介して埋め込まれたもの。 したがって、バージョンの更新は
EndBlockを介して通信します。

EndBlockにはすでに `ConsensusParams`が含まれています。 バージョン情報をに追加できます
ConsensusParamsも次のとおりです。

```
message ConsensusParams {

  BlockSize block_size
  EvidenceParams evidence_params
  VersionParams version
}

message VersionParams {
    uint64 block_version
    uint64 app_version
}
```

これで、ブロックバージョンが許可されないため、 `block_version`は無視されます
アップグレード待ち。 `app_version`が設定されている場合、それは
プロトコルのバージョンが変更され、新しい `app_version`が含まれるようになります
次のブロックの `Block.Header.Version.App`。

###ブロックバージョン

BlockVersionはHeaderとNodeInfoに含まれています。

BlockVersionの変更はめったに行われるべきではなく、理想的には
重要なアップグレード。現在、ABCIでコーディングされていませんが、常にコーディングされています。
タグを使用して、アップグレードを調整するために外部プロセスに信号を送ることができます。

イーサリアムはそのようなアップグレードを実行する必要がないことに注意してください(すべてがステートマシンレベル、AFAIKにあります)。

### P2Pバージョン

P2PVersionはブロックヘッダーに含まれず、NodeInfoにのみ含まれます。

P2PVersionは、NodeInfoの最初のフィールドです。 NodeInfoもproto3であるため、これは読みやすいです。

メッセージを送信するとき、ピアのバージョンを考慮するためにピア/リアクタープロトコルが必要であることに注意してください。

-理解できないメッセージを送信しないでください
-予期しないメッセージを送信しないでください

そうすることは、進行中のアップグレードに固有のものになります。

NodeInfoにはreactorチャネルリストも含まれているため、ピアが理解できないチャネルのメッセージは送信されないことに注意してください。
アップグレードで常に新しいチャネルが使用される場合、これにより下位互換性の開発コストが簡素化されます。

NodeInfoは、プライベートであることを確認するために、認証された暗号化ハンドシェイクの後にのみ交換されることに注意してください。
暗号化前のバージョン交換は、情報漏えいと見なされる可能性がありますが、よくわかりません。
プロトコルをアップグレードできることと比較して、これはどれほど重要ですか。

XXX:必要に応じて、最初のメッセージの最初のバイトの意味を変更して、ハンドシェイクバージョンをエンコードできますか？
これは、32バイトのed25519公開鍵の最初のバイトです。

###アプリケーションバージョン

AppVersionは、ブロックヘッダーとNodeInfoにも含まれています。

AppVersionは、基本的にAppHashとLastResultsの計算方法を定義します。

### ピアの互換性

バージョンに基づいてピアツーピアの互換性を制限することは、必要性のために複雑です
古いバージョンを使用している可能性のある古いピアがブロックチェーンを同期するのを支援します。

私たちは同じものを持つためにのみ接続すると言いたいかもしれません
AppVersionとBlockVersion(これらは重要なコンセンサスを定義するため)
計算)、およびP2PVersionsの選択リスト(つまり、
私たち)、しかし私たちはピアに接続する必要があります
正しいBlock/AppVersionは、それらが配置されている高さに対応します。

現在、任意のバージョンのピアに接続し、互換性を制限します
ChainIDのみに基づいています。ピアに対してより制限的なルールを残しました
将来の提案との互換性。

###将来の変更

`/ unsafe_stop？height = _`エンドポイントをサポートすると、Tendermintに特定の高さでシャットダウンするように指示されます。
これは、アップグレードを監督する外部マネージャープロセスで使用できます。
新しいソフトウェアバージョンを確認してインストールし、プロセスを再開します。それ
関連するアップグレードイベントをサブスクライブし(実装が必要)、で `/ unsafe_stop`を呼び出します
正しい高さ(もちろん、ユーザーの承認後のみ！)

## 結果

### ポジティブ

-ABCIのネイティブTendermintとアプリのバージョンをより明確にする
  彼らとコミュニケーションをとる
-プロトコルバージョンとソフトウェアバージョンを明確に区別する
  他の言語の実装を促進する
-簡単に識別できる方法で主要なデータ構造に含まれるバージョン
-提案者がアップグレードを通知し、アプリが実際にいつ変更するかを決定できるようにします
  バージョン(および新しいバージョンの通知を開始)

### ニュートラル

-最初のP2Pハンドシェイク自体をバージョン管理する方法が明確ではありません
-ピアの互換性を制限するためにバージョンが使用されていません
-シグナルの新しいバージョンは提案者を通じて発生し、
  アプリケーションで記録/追跡します。

### ネガティブ

-ABCIにフィールドを追加します
-単一のコードベースが複数のバージョンを処理できる必要があることを意味します
