# RFC 003:Tendermintの潜在的なパフォーマンス問題の分類

## 変更ログ

-2021-09-02:最初のドラフトを作成します(@wbanfield)
-2021-09-14:イベントシステムのディスカッションを追加(@wbanfield)

## 概要

このドキュメントでは、テンダーミントと
これらの問題を理解して解決するために何が必要かを明確にするようにしてください。

## バックグラウンド

パフォーマンス。ソフトウェアプロセスがその作業を実行する能力として大まかに定義されます。
負荷の範囲内で高速かつ効率的であり、合理的なリソースの制約が一般的です
Tendermintプロジェクトのディスカッショントピック。
テンダーミントのパフォーマンスに関する問題を効果的に解決するには、
さまざまな問題を分類し、それらの潜在的な原因を理解し、それらを測定します
ユーザーへの影響。

さまざまな既知のパフォーマンスの問題を分類することで、それらについて話し合い、修正することができます
より体系的。このドキュメントは、パフォーマンスの問題の大まかな分類を示しています
また、潜在的なパフォーマンスの問題についてさらに調査が必要な領域についても説明します。

Tendermintのパフォーマンスの制限を理解することも重要です
そのサブシステムの多くに変更を加えるとき。パフォーマンスが中心的な関心事です
「p2p」プロトコル、RPCメッセージのエンコーディング、および構造に関する決定が行われようとしています。
データベースの使用と選択、およびコンセンサスプロトコルの更新。


## 議論する

このセクションでは、Tendermintの機能のさまざまな部分について説明します。
パフォーマンスの問題としてよく引用されます。質問をし、推奨事項を作成します
Tendermintのパフォーマンスの問題をよりよく理解するのに役立つ可能性のあるクエリ行。

注:多くのマイクロベンチマークやパッケージレベルのベンチマークをすぐに追加することは避けてください。
これらは、それがどうあるべきかを曖昧にする可能性があるため、役に立たないよりも悪いです
焦点:ユーザーの観点からシステムのパフォーマンスを確認します。我々はすべき、
代わりに、ユーザーのニーズとユーザーが実行する操作に基づいてパフォーマンスを調整します。これらのユーザーには以下が含まれます
テンダーミントチェーンの運営者と取引を行う者
テンダーミントチェーン。大体において、これら2つのユーザーグループはエンドツーエンドを望んでいます
迅速かつ効率的に実行されるシステム。

リクエスト:頻繁に表示される追加のパーツがある場合、以下のリストは不完全な場合があります
パフォーマンスの低下を引き起こしていると言われていますが、コメントを残してください。

### ピアツーピア

#### 免責事項:Tendermintは多数のノードに拡張できません

報告によると、Tendermintネットワークは多数のノードに拡張することはできません。
何千ものノードが、問題を引き起こしているとリストされているユーザーから報告されています。
現在、テンダーミントのノードの上限が何であるかを示す証拠はありません
P2Pスタックはに拡張できます。

問題の根本をより具体的に理解し、それがどのレベルであるかを判断する必要があります
問題を引き起こします。反応器がなくても、P2P層が可能です
データの送信は、何千ものピアツーピア接続を完全に管理できます。にとって
合理的なネットワークとアプリケーションの設定、何千もの接続が表示されるべきではありません
アプリケーションの問題。

問題を直接理解するには、より多くのデータが必要です。人気を高めたい
そして、テンダーミントの採用は、より多くのバリデーターのチェーンを許可することを意味します。
この問題が発生したユーザーをフォローアップする必要があります。次に、追加することができます
P2Pレイヤーが生み出す非効率性をよりよく理解するための、P2Pレイヤーの一連のインジケーター。

次のメトリックは、TendermintP2Pスタックの遅延の原因を理解するのに役立ちます。

* 1秒あたりに送受信されたメッセージの数
*メッセージがキューの送受信に費やす時間

追加されたインジケーターに加えて、次のインジケーターも使用する必要があります。

*接続されているピアの数
*各ピアとの間で送受信されるチャネルあたりのバイト数

### 同期する

#### 免責事項:ブロックの同期が遅い

ネットワーク内の新しいノードがネットワークの残りの部分に誘導される高さが考慮されます
ユーザーの予想よりも時間がかかりました。ブロック同期はからである必要があります
ピアを作成し、ストレージ用にローカルディスクに配置します。便利なクエリ行
完全に調整されたsystem_can_getすべての状態の速度を理解する
ネットワークを介して、Tendermintが実際にどれだけのオーバーヘッドを増やしたかを理解できるようにします。

操作は_信じられないほど_依存している可能性が非常に高いです
ノードは実行中です。同期に影響を与える要因は次のとおりです。
1.同期ノードが同期ノードから取得できるピアの数。
2.バリデーターがディスクに書き込む速度。
3.ノードが配置されている異なるピア間のネットワーク接続速度
から同期。

通常のチェーンとノードでこの操作が完了する速度を計算する必要があります。
この操作が完了するまでの時間を計算するには、次のように仮定する必要があります。
ノードはNICのワイヤ速度で読み取り、フルドライブ速度で書き込みを行っています。
ローカルストレージ。この理論上の上限を実際の同期時間と比較します
ノード演算子の観察は、理解するための比較の良いポイントを提供します
Tendermintはどのくらいのオーバーヘッドを被りますか。

さらに明確に調べるために、同期操作をブロックするインジケーターを追加する必要があります
動作が遅い。次のインジケータをブロック同期操作に追加する必要があります。

*各ブロックを取得して検証する時間
*ブロックを実行する時間
*単位時間ごとに同期されたブロック

### 応用

複雑な状態遷移を実行するアプリケーションがボトルネックになる可能性があります
テンダーミントノード。

#### 免責事項:ABCIブロックの配信が遅くなる可能性があります

ABCIは、 `BeginBlock`、` DeliverTx`、 `EndBlock`、` Commit`などのさまざまな方法でブロックを配信します。

Tendermintは、 `DeliverTx`を介して1対1の配信トランザクションを呼び出します。ほとんど
Tendermintでのトランザクション配信は非同期で行われるため、可能性は低いようです。
ABCIでボトルネックが発生します。

すべてのトランザクションを配信した後、Tendermintは `Commit`ABCIメソッドを呼び出します。
Tendermint [メモリプールへのすべてのアクセスをロックする] [abci-commit-description]そして `Commit`
所得。これは、アプリケーションがそのすべてを実行することを意味します
Commitメソッド中のトランザクションまたは完了ステータスは、新しいものを防ぎます
トランザクションはメモリプールに追加されます。提出が遅い申請書は
テンダーミント以降、コンセンサスが次のコンセンサスの高さに進むのを防ぐ
ブロック提案を検証またはブロック提案を生成できません
`Commit`メソッドから取得したAppHash。各インジケーターにインジケーターを追加する必要があります
ノードが通信に費やす時間を追跡するためのABCIプロトコルのステップ
すべてのステップでアプリ。

#### 免責事項:ABCIシリアル化のオーバーヘッドにより、速度が低下します

Tendermintアプリケーションを実行する最も一般的な方法は、Cosmos-SDKを使用することです。
Cosmos-SDKは、Tendermintと同じプロセスでABCIアプリケーションを実行します。
アプリケーションがTendermintと同じプロセスで実行されている場合、シリアル化のペナルティ
支払っていない。これは、ローカルABCIクライアントがメソッド呼び出しをシリアル化しないためです。
代わりに、protobufタイプが直接渡されます。これは見ることができます
[local_client.go] [abci-local-client-code]内。

gRPCとソケットプロトコルのABCIメソッドでのシリアル化と逆シリアル化
減速の原因となります。これらは問題を引き起こす可能性がありますが、
Tendermintのユースケースは、現時点で必ずしも解決する必要はありません。

### RPC

#### 免責事項:クエリAPIは非常に低速です。

クエリAPIは、ABCI接続間でミューテックスをロックします。これはコンセンサスにつながります
ABCIは進行できなくなったため、クエリ中は遅くなります。それは、よく知られています
cosmos-sdkで問題が発生し、[in sdk] [sdk-query-fix]で解決されます
ただし、より強力なソリューションが必要になる場合があります。各ABCIクライアント接続にメトリックを追加します
そして、このドキュメントのアプリケーションセクションで説明されているメッセージは私たちを可能にします
ここでこの問題をさらに詳しく調べます。

#### 免責事項:RPCシリアル化が遅くなる可能性があります

Tendermint RPCは、JSON-RPCの修正バージョンを使用します。このRPCは、 `broadcast_tx _ *`メソッドを強化します。
これは現在、Tendermintにトランザクションを追加するための重要な方法です。この方法は
人気のあるネットワークで頻繁に呼び出される可能性があります。効率的に実行できる
この一般的で重要な操作にとって非常に重要です。現在のJSON-RPC実装
非常に遅いことが知られている反射による型のイントロスペクションに大きく依存します
と一緒に行きます。したがって、このメソッドのベンチマークを生成して、どのくらいのオーバーヘッドがあるかを判断する必要があります
非常に一般的な操作を追加しています。

他のJSON-RPCメソッドは、Tendermintのコア機能にとってそれほど重要ではありません。
RPCには他のパフォーマンスの考慮事項があるかもしれませんが、考慮されていないメソッド
パフォーマンス上の理由から、多数のリクエストを受信することを優先するべきではありません。

注:RPCフレームワークに関する以前の説明は、[ADR 57] [adr-57]および
[RFC 002] [rfc-002]のJSON-RPCフレームワークは、レビューおよび変更されています。
これらのRPC関連のパフォーマンスに関する考慮事項のほとんどは、RFC002の作業が完了するまで待つことができます。
JSON-RPCの動的な変更と一致していることを考慮してください。

### 合意

#### 免責事項:ゴシップメッセージングは​​遅いプロセスです

現在、バリデーターがconsensus_step_で正常に投票するには、
ネットワーク上のバリデーターの2/3以上から投票を取得します。多くの場合、
正しいバリデーターからできるだけ多くの票を獲得するのが最善です。

より多くのバリデーターがネットワークに参加すると、配信されるメッセージが2番目に増加します。
(N個のバリデーターのそれぞれは、他のすべてのN-1バリデーターと通信する必要があります)。

各ステップで伝達される多数のメッセージは、影響を与えると判断されています
契約の実施。伝達されたメッセージの数を考えると
ボトルネックとして特定され、どのくらいの期間が非常に価値があるかに関するデータを収集する
多くのバリデーターを持つ人気のあるチェーンは、すべての投票を1つのステップで収集する必要があります。

この可視性を向上させることができるメトリックは次のとおりです。

*ノードが1つのステップで投票を収集する時間。
*ノードがすべてのブロックパーツを収集する時間。
*各ノードがゴシップに送信する投票数(つまり、それはそれ自体の投票ではなく、その投票数)
ピアツーピア伝送の場合)。
*各ノードから送信された投票の総数(ノードは重複した投票を受け取る場合があります)
したがって、これがどのくらいの頻度で発生するかを知ることは、パフォーマンスを評価するために価値があります
ゴシップシステム)。

#### ステートメント:Txをハッシュすると、Tendermintの速度が低下します

Txハッシュに高速ハッシュアルゴリズムを使用することが現在の議論のポイントです
テンダーミントで。つまり、[Modular Hash Proposal] [ModularHash]の一部と見なされます。
Mempoolでのハッシュトランザクションが主要なボトルネックを構成するかどうかは明らかではありません。
遅いとは思われませんが、オープンなgithubがいくつかあります
ユーザーがより高速なハッシュアルゴリズムを好む可能性があることを示します。
[issue 2187] [issue-2187]と[issue2186] [issue-2186]を含めます。

他のハッシュと比較して、Txハッシュの大きさのオーダーは研究する価値があるかもしれません
Txアスペクトをメモリプールに追加します。 Txレートを上げる方法が明確ではありません
メモリプールはユーザーの苦痛の原因です。私たちはしようとすべきではありません
変更が高度であると最初に判断せずにコンセンサスに到達するための重要なコンポーネント
価値と影響。

### デジタル署名

#### 免責事項:デジタル署名の検証により、Tendermintの速度が低下する可能性があります

暗号化署名を使用すると、計算コストが高くなる可能性があります。宇宙
ハブは[ed25519署名] [ハブ署名]を使用します。ライブラリ実行署名
Tendermintでの投票の検証は、[benchmark] [ed25519-bench]が `ed25519`を実行できることです。
かなり高速なCPUで75μsで署名されています。 CosmosHubでのバリデーターの実行
ハブ内の140の検証者の署名に対して3セットの検証を実行します
コンセンサスラウンドでは、ブロック検証期間中、事前投票を検証するとき、および
事前コミットを確認するとき。バッチ処理がない場合、これはほぼ「3ms」ごとになります
円形。したがって、これが深刻な金額を引き起こす可能性は低いです
ハブ内の各高さのブロック時間は約7秒です。

プロセスには継続的な検証が必要なため、同期が遅くなる可能性があります
サイン。シグニチャ集約の改善は、改善につながる可能性があります
ライトクライアントまたはその他の同期機能。一般的に、メトリックを追加する必要があります
ブロック同期中のブロックレートを追跡します。

#### 免責事項:コンセンサスプロトコルでデジタル署名を使用すると、パフォーマンスの問題が発生します

現在、Tendermintのデジタル署名検証にはすべての検証者が必要です
すべての投票メッセージを受信します。各検証者は完全なデジタル署名を受け取る必要があります
対応する投票メッセージと一緒に。これは、N個のバリデーターすべてが
各コンセンサスのN個のバリデーターの少なくとも2/3からメッセージを受信する必要があります
円形。奇妙な形のネットワークトポロジの可能性と期待を考慮する
ブロックチェーン内の数百ミリ秒の可変ネットワークラウンドトリップ時間、
この種のゴシップは多くの原因となる可能性があります
コスモスハブとテンダーミントのコンセンサスは鈍化しました。

### テンダーミントイベントシステム

#### ステートメント:イベントシステムはテンダーミントのボトルネックです

テンダーミントイベントシステムは、通信およびストレージ関連に使用されます
内部テンダーミントの実行。システムはチャネルを使用してメッセージを内部的に送信します
別の加入者に。イベントの送信[内部チャネルのブロック] [イベントの送信]。
デフォルトの設定は、[イベントの公開にバッファなしのチャネルを使用する] [イベントバッファ容量]です。
イベントシステムの一部のコンシューマーも、読み取りにバッファーなしのチャネルを使用します。
この例は、[event indexer] [event-indexer-unbuffered]であり、これには
イベントシステムへのバッファなしサブスクリプション。結果は、これらのバッファリングされていないリーダーです
場合によっては、イベントシステムへの書き込みがブロックまたは遅くなる可能性があります
イベントシステム。これは、[リリースイベント] [コンセンサス-イベント-送信]のコンセンサスシステムに影響を与えます。
イベントシステムのパフォーマンスをよりよく理解するために、イベントがいつ発生したかを追跡するためのメトリックを追加する必要があります
イベントが送信されました。次のメトリックは、このパフォーマンスを追跡するための良いスタートになります。

*イベントタイプでマークされたイベント送信時間
*加入者によってマークされたイベント受信時間
*イベントスループット。単位時間あたりのイベント数で測定されます。

### 参照する
[モジュラーハッシュ]:https://github.com/tendermint/tendermint/pull/6773
[issue-2186]:https://github.com/tendermint/tendermint/issues/2186
[issue-2187]:https://github.com/tendermint/tendermint/issues/2187
[rfc-002]:https://github.com/tendermint/tendermint/pull/6913
[adr-57]:https://github.com/tendermint/tendermint/blob/master/docs/architecture/adr-057-RPC.md
[issue-1319]:https://github.com/tendermint/tendermint/issues/1319
[abci-commit-description]:https://github.com/tendermint/spec/blob/master/spec/abci/apps.md#commit
[abci-local-client-code]:https://github.com/tendermint/tendermint/blob/511bd3eb7f037855a793a27ff4c53c12f085b570/abci/client/local_client.go#L84
[中央署名]:https://github.com/cosmos/gaia/blob/0ecb6ed8a244d835807f1ced49217d54a9ca2070/docs/resources/genesis.md#consensus-parameters
[ed25519-ベンチ]:https://github.com/oasisprotocol/curve25519-voi/blob/d2e7fc59fe38c18ca990c84c4186cba2cc45b1f9/PERFORMANCE.md
[イベント送信]:https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/libs/pubsub/pubsub.go#L338
[イベントバッファ容量]:https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/types/event_bus.go#L14
[イベントインデクサーはバッファリングされません]:https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/state/indexer/indexer_service.go#L39
[コンセンサスイベント送信]:https://github.com/tendermint/tendermint/blob/5bd3b286a2b715737f6d6c33051b69061d38f8ef/internal/consensus/state.go#L1573
[sdk-query-fix]:https://github.com/cosmos/cosmos-sdk/pull/10045
